
! Function (a, b) {"objeto" == tipo de módulo && "objeto" == typeof module.exports? Module.exports = a.document? B (a,! 0): function (a) {if .document) throw new Erro ("jQuery requer uma janela com um documento"); return b (a)}: b (a)} ("undefined"! = Window typeof window: this, function (a, b) Var c = [], d = a.documento, e = c.slice, f = c.concat, g = c.push, h = c.indexOf, i = {}, j = i.toString, k = i (A, b) {return new n.fn.init (a, b)}, o = / ^ [\ s \ uFEFF \ xA0 G / r, g, r = função (a, b) (return)] + | [\ s \ uFEFF \ xA0] B.toUpperCase ()}; n.fn = n.prototype = {jquery: m, construtor: n, selector: "", length: 0, toArray: function () (A) {return null! = A? 0> a? This [a + this.length]: this [a]: e.call (this)}, pushStack: função (a) {var b = n.merge (This.constructor (), a); return b.prevObject = this, b.context = this.context, b}, each: function (a) {return n.each (this, a) A) {return this.pushStack (n.map (isto, função (b, c) {return a.call (b, c, b)}))}, slice: function () {return this.pushStack (e. (), First: function () {return this.eq (0)}, last: function () {return this.eq (-1)}, eq: função (a) {var b = This this comprimento, c = + a + (0> a? B: 0); return this.pushStack (c> = 0 && b> c? .prevObject || this.constructor ()}, push: g, classificar: c.sort, splice: c.splice}, n.extend = n.fn.extend = função () {var a, b, c, d , F, g = argumentos [0] || {}, h = 1, i = argumentos.length, j =! 1; para ("booleano" == tipo de g && (j = g, g = argumentos [h ] || {}, h ++), "object" == typeof g || n.isFunção (g) || (g = {}), h === i && (g = this, h-) H, h ++) se (null! = (E = argumentos [h])) para (d em e) a = g [d], c = e [d], g! == c && (n.isPlainObject C) || (b = n.isArray (c))) (b? (B =? 1, f = a && n.isArray (a)? A: []): f = a && n.isPlainObject (a)? A : {}, G [d] = n.extend (j, f, c)): void 0! == c && (g [d] = c)); return g}, n.extend ({expando: "jQuery (A) {throw new Erro (a)}, noop: function () {+ (m + Math.random () }, IsFunction: function (a) {return "function" === n.type (a)}, isArray: Array.isArray || função (a) {return "array" === n.type (a)} , IsWindow: function (a) {return null! = A && a == a.window}, isNumeric: função (a) {var b = a && a.toString (); return! N.isArray (a) && b-parseFloat (b) 1> = 0}, isEmptyObject: function (a) {var b; para (b em a) return! 1; return! 0}, isPlainObject: função (a) {var b; if (! A || "object "! == n.type (a) || a.nodeType || n.isWindow (a)) return! 1; try {if (a.constructor &&! K.call (a," constructor ") &&! K. (A.constructor.prototype, "isPrototypeOf")) return! 1} catch (c) {return! 1} se (! L.ownFirst) para (b em a) return k.call (a, b); (B em a), return void 0 === b || k.call (a, b)}, tipo: function (a) {return null == a? A + "": "object" == typeof a | | "Function" == typeof a? I [j.call (a)] || "objeto": typeof a}, globalEval: função (b) {b && n.trim (b) && (a.execScript || function B) {a.eval.call (a, b)}), camelCase: função (a) {return a.replace (p, "ms-"). Replace (q, r)} nodeName: (A, b) {return a.nodeName && a.nodeName.toLowerCase () === b.toLowerCase ()}, cada: function (a, b) {var c, d = 0; if (s (a) {Para (c = a.length; c> d; d ++) se (b.call (a [d], d, a [d]) ===! B.call (a [d], d, a [d]) ===! 1) break, return a}, trim: função (a) {return null == a? "" :( a + ""). (A, b) {var c = b || []; return null! = A && (s (Object (a))? N.merge (c, "string" (A, a): a): g.call (c, a)), c}, inArray: função (a, b, c) (B, a, c), para (d = b.length, c = c? 0> c? Math.max (0, d + c): c Em b && b [c] === a) retorna c} return-1}, funde: função (a, b) {var c = + b.length, d = 0, e = a.length; ) A [e ++] = b [d ++]; se (c! == c) enquanto (void 0! == b [d]) a [e ++] = b [d ++] , Grep: função (a, b, c) {para (var d, e = [], f = 0, g = a.length, h = F], f), d! == h && e.push (a [f]); return e}, mapa: função (a, b, c) {var d, e, g = 0, h = (S (a)) para (d = a.length; d> g; g ++) e = b (a [g], g, c), null! = E && h.push (e) ), Guid: 1, proxy: function (a, b) {e} = b (a [g], g, c) B = a, a = f), n.função (a)? (C = e.call (argumentos, 2) , D = function () {return a.apply (b || this, c.concat (e.call (argumentos))}, d.guid = a.guid = a.guid || n.guid ++, d) : Void 0}, agora: function () {return + new Date}, support: l}), "function" == typeof Symbol && (n.fn [Symbol.iterator] = c [Symbol.iterator]), n. Cada função de função (a, b) {i ["[objeto" + b + "]"] = b.toLowerCase ()}); função (A) {var b = !! a && "length" em um && a.length, c = n.type (a); return "function" === c || n.isWindow (a) ?! "=== c || 0 === b ||" número "== tipo de b && b> 0 && b-1 em a} var t = função (a) {var b, c, d, e, f, g, h M, n, o, p, q, r, s, t, u = "sizzle" + 1 * data, v = a.documento, w = 0, x = 0, (= 0), 0}, C = 1 << 31, a = a, b = D = {}. HasOwnProperty, E = [], F = E.pop, G = E.push, H = E.push, I = E.slice, J = função (a, b) 0, d = a.length; d> c; c ++) se (a [c] === b) retorno c; retorno-1}, K = "selecionado | selecionado | async | autofoco | autoplay | controles | Desabilitado, oculto, ismap, loop, múltiplo, aberto, readonly, required, scoped, L = "[\\ x20 \\ t \\ r \\ n \\ f]", M = " \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ " () () (): () () () () () () () () \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ " -benzóico.?: \ "(?: \\\\. | [^ \\\\\ -benzóico. -benzóico. -benzóico. , P = new RegExp (L + "+", "g"), Q = new RegExp ("^" + L + "+ | ((?: ^ | [^ \\\\]) (?: \\\\ ), S = new RegExp ("^" + L + "*)"), S = new RegExp ("^" + L + "+ (+ L +) + T "+ L +"), T = new RegExp ("=" + L + "* ([^ \\] \ "), U = new RegExp (O), V = new RegExp (" ^ "+ M +" $ "), W = {ID: new RegExp (" ^ # ("+ M +") "), CLASSE: novo RegExp (" ^ \\. ("+ M +") "), TAG: novo RegExp (" ^ " + N), PSEUDO: novo RegExp ("^" + O), CRILD: new RegExp ("^ :( only | first | last | nth | nth-last) ("+ L +" * (?: ([+ -] |) "+ L +" * (\ \ "+" + ")") "), Bool: new RegExp (" ^ (?: "+ K +") $ "," i "), needsContext: new RegExp ("^" + L + "* [> + ~] |: (even | odd | eq | gt | lt | nth | first | last) (?: \\ (" + L + "* ((?: - \\ D)? \\ d *) "+ L +" * \\))), X = / ^ (?: Input | select | textarea | button ) $ / I, Y = / ^ h \ d $ / i, Z = / ^ [^ {] + \ {\ s * \ [ ] +) | (\ W +) | \. ([\ W-] +)) $ /, _ = / [+ ~] /, aa = / '| \\ / g, ba = new RegExp ("\\ \\ ([\\ da-f] {1,6} "+ L +"? | ("+ L +")), ca = função (a, b, c) {var d = "0x" + b-65536; return d! == d || c? B: 0> d? String.fromCharCode (d + 65536): String.fromCharCode (d >> 10 | 55296,1023 & d | 56320)} , Da = function () {m ()}; try {H.apply (E = I.call (v.childNodes), v.childNodes), E [v.childNodes.length] .nodeType} catch (ea) { H = {apply: função de comprimento de E. (a, b) {G.apply (a, I.call (b)): função (a, b) {var c = a.length, d = 0; (A [c ++] = b [d ++]); a.length = c-1}}} função fa (a, b, d, e) {var f, h, j, k, l, o, r, s , W = b && b.ownerDocument, x = b? B.nodeType: 9; if (d = d || [], "string"! = Typeof a ||! A || 1! == x && 9! == x && 11! == x) return d; if (! E && (b? B.ownerDocument || b: v)! == n && m (b), b = b || n, p)) {if (11! == x && (F = o [1]) {if (9 === x) {if (! (J = b.getElementById (f))) retorna d; if (j .id === f) return d.push (j), d} senão se (w && (j = w.getElementById (f)) && t (b, j) && j.id === f) J), d} else {if (o [2]) return H.apply (d, b.getElementsByTagName (a)), d; if ((f = o [3]) && c.getElementsByClassName && b.getElementsByClassName) return H. (D, b.getElementsByClassName (f)), d} if (c.qsa &&! A [a + ""] && (! Q ||! Q.test (a) W = b, s = a; else if ("objeto"! == b.nodeName.toLowerCase ()) {(k = b.getAttribute ("id"))? K = k.replace (aa, "\\ $ \ "): B.setAttribute (" id ", k = u), r = g (a), h = r.length, l = (H -) r [h] = l + "" + qa (r [h]); s = r.join (","), w = ) && oa (b.parentNode) || b} se (s) try {return Happly (d, w.querySelectorAll (s)), d} catch (y) {} finalmente {k === u && b.removeAttribute () () () () () () () () () () () () () () () () () () (C + "")> d.cacheLength && delete b [a.shift ()], b [c + ""] = e} retorno b} função ha (a) {retorno a [u] =! 0, a} função ia (B), b = b.parentNode.removeChild (b), b = b.parentNode.removeChild (b), b = n.createElement ("div" E (c), enquanto que (e -) d.attrHandle [c [e]] = b} função ka (a, b) A), b) {var c = b && a, d = c && 1 === a.nodeType && 1 === b.nodeType && (~ b.sourceIndex || C) - (~ a.sourceIndex || C) (C) while (c = c.nextSibling) if (c === b) return-1; return a? 1: -1} função la (a) {função de retorno (b) {var c = b (A) {função de retorno (b) {var c = b.nodeName.toLowerCase (); return ("input "=== c" "== c) && b.type === a}} função na (a) {retorno ha (função (b) {retorno b = + b, ha (função (c, D) {var e, f = a ([], c.length, b), g = f.length; enquanto (g -) c [e = f [g]] && (c [e] =! D = e) =) function} a) {return a && "undefined"! = Typeof a.getElementsByTagName && a} c = fa.support = {}, f = fa.isXML = função (A) {var b = a && (a.ownerDocument || a) .documentElement; return b? "HTML"! == b.nodeName:! 1}, m = fa.setDocument = função (a) {var b, E, g = a? A.ownerDocument || a: v; return g! == n && 9 === g.nodeType && g.documentElement? (N = g, o = n.documentElement, p =! F (n), E = n.defaultView) && e.top! == e && (e.addEventListener? E.addEventListener ("unload", da,! 1): e.attachEvent && e.attachEvent ("onunload", da)), c.attributes = (Função (a) {return a.className = "i",! A.getAttribute ("className")}), c.getElementsByTagName = ia (função (a) {return a.appendChild (n.createComment (" )), C.getElementsByClassName = Z.test (n.getElementsByClassName), c.getById = ia (função (a) {return o.appendChild (a) .id = U,! N.getElementsByName ||! N.getElementsByName (u) .length}), c.getById? (D.find.ID = função (a, b) {if ("undefined"! = Typeof b.getElementById && p ) {Var c = b.getElementById (a); retorno c? [C]: []}}, d.filter.ID = função (a) {var b = a.replace (ba, ca) A) {return a.getAttribute ("id") === b}}) :( delete d.find.ID, d.filter.ID = função (a) {var b = a.replace (ba, ca) ; Função return (a) {var c = "undefined"! = Typeof a.getAttributeNode && a.getAttributeNode ("id"); retorno c && c.value === b}}), função d.find.TAG = c.getElementsByTagName? (A, b) {return "undefined"! = Typeof b.getElementsByTagName? B.getElementsByTagName (a): c.qsa? B.querySelectorAll (a): void 0}: função (a, b) {var c, d = [], E = 0, f = b.getElementsByTagName (a); if ("*" === a) {while (c = f [e ++]) 1 === c.nodeType && d.push (c); Return d} return f}, d.find.CLASS = c.getElementsByClassName && função (a, b) {return "indefinido"! = Typeof b.getElementsByClassName && p? B.getElementsByClassName (a): void 0}, r = [], q = [], (C.qsa = Z.test (n.querySelectorAll)) && (ia (function (a) {o.appendChild (a) .innerHTML = "<a id='"+u+"'> < A> <select id = '"+ u +" - \ r \\' msallowcapture = ''> <option selected = ''> </ option> </ select> ", a.querySelectorAll ] "), A.querySelectorAll (" [selected] "). Length && q.push (" [* ^ $] = "+ L +" ("\\ [" + L + "*), a.querySelectorAll (" [id ~ = "+ u +" -] "). Length || q.push (" (): A.querySelectorAll (": checked"). Length || q.push (": checked"), a.querySelectorAll ("a #" + u + "+ *"). B.setAttribute ("type", "hidden"), a.appendChild () () () () () () B) .setAttribute ("name", "D"), a.querySelectorAll ("[name = d]"). Length && q.push ("name" + L + "* [* ^ $ | , A.querySelectorAll (": enabled"). Q.push (": enabled", ": disabled"), a.querySelectorAll (": enabled"), q.push (",. *: ")})), (C.matchesSelector = Z.test (s = o.matches || o.webkitMatchesSelector || o.mozMatchesSelector || o.oMatchesSelector || o.msMatchesSelector)) && ia (função (a) {c .disconnectedMatch = s.call (a, "div"), s.call (a, "[s! = '']: X"), r.push ("! =", O) .length && new RegExp (q.join ("|")), r = r.length && new RegExp (r.join ("|")), b = Z.test (o.compareDocumentPosition), t = b || Z.test (O.contains)? Função (a, b) {var c = 9 === a.nodeType? A.documentElement: a, d = b && b.parentNode; retorno a === d ||! (! D || 1 = = d.nodeType ||! (C.contains? C.contains (d): a.compareDocumentPosition && 16 & a.compareDocumentPosition (d)))}: função (a, b) (B === a) return! 0; return! 1}, B = função b (a, b) {if (a === b) retorno l =! 0,0; var d = ! A.compareDocumentPosition-! B.compareDocumentPosition; return d? D: (d = (a.ownerDocument || a) === (b.ownerDocument || b)? A.compareDocumentPosition (b): 1,1 & d || ! C.sortDetached && b.compareDocumentPosition (a) === d? A === n || a.ownerDocument === v && t (v, a)? - 1: b === n || b.ownerDocument === V && t (v, b)? 1: k? J (k, a) -J (k, b): 0: 4 & d? -1: ) Retorna l =! 0,0; var c, d = 0, e = a.parentNode, f = b.parentNode, g = [a], h = [b]; if (! E ||! F) return A === n? -1: b === n? 1: e? -1: f? 1: k? J (k, a) -J (k, b): 0; C) c = b; enquanto (c = c.parentNode) h.unshift (c), enquanto (c = c.parentNode) g.unshift (c) G [d] === h [d]) d ++; retorno d? Ka (g [d], h [d]): g [d] === v? -1: h [d] === v (A, b) {f (a, nulo, nulo, b)}, fa.matchesSelector = função (a, b) {if ( A.ownerDocument || a)! == n && m (a), b = b.replace (T, "= '$ 1']"), c.matchesSelector && p &&! A [b + ""] && (! R ||! R (B)) && (! Q ||! Q.test (b))) try {var d = s.call (a, b); if (d || c.disconnectedMatch || a.document && 11! = = A.document.nodeType) return d} catch (e) {} retornar fa (b, n, null, [a]). Comprimento> 0}, fa.contains = função (a, b) {return (a. OwnerDocument || a)! == n && m (a), t (a, b)}, fa.attr = função (a, b) {(a.ownerDocument || a)! == n && m (a); var e = D.attrHandle [b.toLowerCase ()], f = e && D.call (d.attrHandle, b.toLowerCase ())? E (a, b,! P): void 0; return void 0! == f? F: c.attributes ||! P? A.getAttribute (b) :( f = a.getAttributeNode (b)) && f.specified? F.value: null}, fa.error = function (a) {throw new Error ("Erro de sintaxe, expressão não reconhecida:" + a)}, fa.uniqueSort = função (a) {var b, d = [], e = 0, f = 0; (B = a [f ++]) b === a [f] && (e = d.push (f)), enquanto que (E -) a.splice (d [e], 1)} retorno k = nulo, a}, e = fa.getText = função (a) {var b, c = A.nodeType; if (f) {if (1 === f || 9 === f || 11 === f) {if ("string" == typeof a.textContent) return a.textContent; for (A = a.firstChild; a; a = a.nextSibling) c + = e (a)} else if (3 === f || 4 === f) return a.nodeValue else while (b = a [ D = fa.selectors = {cacheLength: 50, createPseudo: ha, match: W, attrHandle: {}, find: {}, relative: {">" {Dir: "parentNode", primeiro:! 0}, "": {dir: "parentNode"}, "+": {dir: "previousSibling" "}}, PreFilter: {ATTR: função (a) {return a [1] = a [1] .replace (ba, ca), a [3] = (a [3] || a [4] || A [5] || ""). Substituir (ba, ca), "~ =" === a [2] && (a [3] = "" + a [3] + "") (0,4)}, CRIANÇA: function (a) {return a [1] = a [1] .toLowerCase (), "nth" === a [1] .slice (0,3) 3] || fa.error (a [0]), a [4] = + (a [4]? A [5] + (a [6] || 1): 2 * ("even" === A [3] || "odd" === a [3])), a [5] = + (a [7] + a [8] || "impar" === a [3])) A [3] && fa.error (a [0]), a}, PSEUDO: função (a) {var b, c =! A [6] && a [2] ) Null: (a [3]? A [2] = a [4] || a [5] || "": c && U.test (c) && (b = g (c,! 0)) && B = c.indexOf (")", c.length-b) -c.length) && (a [0] = a [0] .slice (0, b), a [2] = c.slice (0 , B)), a.slice (0,3))}}, filtro: {TAG: função (a) {var b = a.replace (ba, ca) .toLowerCase (); return "*" === A função () {return! 0}: função (a) {return a.nodeName && a.nodeName.toLowerCase () === b}}, CLASS: função (a) {var b = y [a + ""]; Return b || (b = new RegExp ("(^ |" + L + ")" + a + "(" + L + "| $)")) && y (a, função (a) {return b.test ("string "=" Typeof a.className && a.className || "undefined"! = Typeof a.getAttribute && a.getAttribute ("class")}})}, ATTR: função (a, b, c) {return function D) {var e = fa.attr (d, a); return null == e? "! =" === b: b? (E + = "", "=" === b? E === C: "! =" == c: "^ =" === b? C && 0 === e.indexOf (c): "* =" === b? C && e.indexOf C)> - 1: "$ =" === b? C && e.slice (-c.length) === c: "~ =" === b? ("" + E.replace (P, "" ) + "") .indexOf (c)> - 1: "| =" === b? E === c || e.slice (0, c.length + 1) === c + "-": 1): 0), CHILD: função (a, b, c, d, e) {var f = "nth"! == a.slice (0,3), g = "last"! (A) {return !! a.parentNode}: função (b, c, d) R = h && b.nodeName.toLowerCase (), s = "b", "=", " (M = m [p]) if (h? M.nodeName.toLowerCase () = f () == r: 1 === m.nodeType) return! 1; o = p = "only" === a &&! O && "nextSibling"} return! 0} if (o = [g? Q.firstChild: q. M = u, m = u, m = u), k = l [m.uniqueID] || (l [m.uniqueID] = {}), J = k [a] || [], n = j [0] === w && j [1], t = n && j [2], m = n && q.childNodes [n] ] || (t = n = 0) || o.pop ()) if (1 === m.nodeType && ++ t && m === b) {k [a] = [w, n, t] }} Else if (s =), k = l [m.uniqueID] || (l [m.uniqueID] = {}) (m = b, l = m [u] , J = k [a] || [], n = j [0] === w && j [1], t = n), t ===! 1) enquanto (m = ++ n && m && m [p] || (T = n = 0) || o.pop ()) if ((h? M.nodeName.toLowerCase () === r: 1 === m.nodeType) && ++ t && (s = [U] || (m [u] = {}), k = l [m.uniqueID] || (l [m.uniqueID] = {}), k [a] = [w, t]) m === b)) break, return = = e, t === d || t% d === 0 && t / d> = 0}}}, PSEUDO: função (a, b) {var c, e = D.pseudos [a] || d.setFilters [a.toLowerCase ()] || fa.error ("não suportado pseudo:" + a); return e [u]? E (b): e.length> 1 ? (C = [a, a, "", b], d.setFilters.hasOwnProperty (a.toLowerCase ())? Ha (função (a, c) {var d, f = e (a, b) = F.length, enquanto (g -) d = J (a, f [g]), a [d] =! (C [d] = f [g] (A, 0, c)}): e}}, pseudos: {não: ha (função (a) {var b = [], c = ), H = a.length, enquanto que (h - ()), (B [h] = f))): função (a, e, f) {retorno b [0] = a, d (b, (Função (a) {função de retorno (b) {retorno fa (a, b) .length> 0 (), Contém: ha (função (a) {return a = a.replace (ba, ca), função (b) {return (b.textContent || b.innerText || e (b)) indexOf A)> - 1}}), lang: ha (função (a) {return V.test (a || "") || fa.error ("unsupported lang:" + a), a = a.replace Ba, ca) .toLowerCase (), função (b) {var c; do se (c = p? B.lang: b.getAttribute ("xml: lang") || b.getAttribute ("lang" C = c.toLowerCase (), c === a || 0 === c.indexOf (a + "-"); while ((b = b.parentNode) && 1 === b.nodeType); return! 1 }}, Target: function (b) {var c = a.location && a.location.hash; return c && c.slice (1) === b.id}, raiz: function (a) {return a === o }, Foco: function (a) {return a === n.activeElement && (! N.hasFocus || n.hasFocus ()) && !! (a.type || a.href || ~ a.tabIndex)} , Habilitado: function (a) {return a.disabled ===! 1}, disabled: função (a) {return a.disabled ===! 0}, verificado: function (a) {var b = a.nodeName .toLowerCase (); return "input" === b && !! a.checked || "option" === b && !! a.selected}, selecionado: function (a) {return a.parentNode && a.parentNode.selectedIndex, A.selected ===! 0}, empty: function (a) {for (a = a.firstChild; a; a = a.nextSibling) if (a.nodeType <6) return! 1; return! 0} (A) {return Y.test (a.nodeName)}, input: função (a) {return X.test (a) {return! D.pseudos.empty (a) .nodeName)}, button: function (a) {var b = a.nodeName.toLowerCase (); return "input" === b && "button" === a.type || "button" === b} , Texto: function (a) {var b; return "input" === a.nodeName.toLowerCase () && "text" === a.type && (null == (b = a.getAttribute ("type") ), Em primeiro lugar: na (function () {return [0]}), última: na (função (a, b) {return [b-1]} ), Eq: na (função (a, b, c) {return [0> c? C + b: c]}) (A) (b) (a) (b) c (c) = c) (A, b, c) {para (var d = 0> c? C + b: c; - d> = 0;) a.push (d); return A}), gt: na (função (a, b, c) {para (var d = 0> c? C + b: c; ++ d <b; }, D.pseudos.nth = d.pseudos.eq; for (b em {radio:! 0, checkbox:! 0, file:! 0, password:! 0, image:! 0}) d.pseudos [ B] = la (b), para (b em {submit:! 0, reset:! 0}) d.pseudos [b] = ma (b) D.pseudos, d.setFilters = new pa, g = fa.tokenize = função (a, b) {var c, e, f, g, h, i, j, k = z [a + K) retorna b? 0: k.slice (0), h = a, i = [], j = d.preFilter, enquanto (h) {e &&! (H = h.slice (e [0] .length) || h), i.push (f = [])), c =! 1, (e = S.exec (h)) && (c = e .shift (), f.push ({valor: c, tipo: e [0] .replace (Q, "")}), h = h.slice (c.length)) para (g in d.filter (E = W [g] .exec (h)) || j [g] &&! (E = j [g] (e)) || (c = e.shift () Valor: c, tipo: g, correspondências: e}), h = h.slice (c.length)); if (! C) break} return b? H.length: h? Fa.error (a): z (A, i) .slice (0)}, função qa (a) {para (var b = 0, c = a.length, d = ""; c> b; b ++) d + = a [b] .value (B, c, f) {d, f = x ++; return b} função (a, b, c) Enquanto (b = b [d]) se (1 === b.nodeType || e) retorna a (b, c, f)}: função (b, c, g) {var h, i, j, k = [W, f], se (g) {while (b = b [d]) se ((1 === b.nodeType || e) && a (b, c, g) (B = b [d]) se (1 === b.nodeType || e) {if (j = b [u] || (b [u] = {}), i = j [b.uniqueID] () () () () () () () () () () () (1) f = (A) {return a.length> 1? Função (b, c, d) {} (E) (b, c, d)) return! 1; return! 0}: a [0]} função ta (a, b, c ) Para (var d = 0, e = b.length; e> d; d ++) fa (a, b [d], c) retorno c} função ua (a, b, c, d, Para (var f, g = [], h = 0, i = a.length, j = null! = B; i> h; h ++) (f = a [h]) && (c &&! (G, p, d, e, f) {return d &&! D [u] && (g.push (f), j && b.push (h) D = va (d)), ha (função (f, g, h, i) {var j, k, l, m = [] , N = [], o = g.length, p = f || ta (b || "*", h.nodeType? [H]: h, []), q = | a ||! F && b? P : Ua (p, m, a, h, i), r = c? E || (f? A: o || d)? ), J = ua (r, n), d (j, [], h, i), k = j.length, enquanto (k-) (l = j [k] (F) {if (e || a) {if (e) {j = [], k = r.length; (K -) (k = l); e (null, r = [], j, i) k = r.length, enquanto (k- ) (L = r [k]) && (j = e? J (f, l): m [k] = Ua (r === g? R.splice (o, r.length): r), e? E (null, g, r, i): A) {for (var b, c, e, f = a.length, g = d.relative [a [0] .type], h = g || d.relative [""], i = g? 1 : 0, k = ra (função (a) {retorno a === b}, h,! 0), l = ra (função (a) {retorno J (b, a)> - 1}, h ,! 0), m = [função (a, c, d) {var e =! G && (d || c! == j) || ((b = c) .nodeType? K (a, c, d): L (a, c, d)), return b = null, e}]; f> i; i ++) if (c = d.relative [a [i] (C = d.filter [a [i] .type] .apply (null, a [i] .matches), c [u]) {for (e = ++ i; f > E (e) e) se (d.relative [a [e] .type]) break; return va (i> 1 && sa (m), i> 1 && qa (a.slice (0, i-1) : "" === a [i-2] .type? "*": ""})). Substituir (Q, "$ 1"), c, e> i && wa (a.slice (i, e) (A) () () () () () () () () () f 0, e = a.longo> 0, f = função (f, g, h, i, k) {u, [], V = j, x = f || e & d.find.TAG ("*", k), y = w + = null == v? 1: Math.random () || .1, z = x. Comprimento, para (k && (j = g === n || g || k); s! == z && null! = (L = x [s) || l.ownerDocument === n || (m (l), h =! P), enquanto (q = a [o ++]) se (q (l, g || n, h)) {i.push (L); break} k && (w = y)} c && (l =! Q && l) && r-, f && t.push (l))} if (r + = s, c && s! Enquanto (q = b [o ++]) q (t, u, g, h), se (f) {if (r> 0) enquanto (s-) t [s] || u [s] || U [s] = F.call (i)); u = ua (u)} happly (i, u), k &&! F && u.length> 0 && r + b.length> 1 && fa.uniqueSort (i) (F = f): f} return h = fa.compile = função (a, b) {var c, d = [], e = [], F = A [a + ""], se (! F) {b || (b = g (a)), c = b.length; enquanto (c-) f = wa (b [c] (F): e.push (f): f = A (a, xa (e, d)), f.selector = a} retorno f}, i = fa.select = função ( A, b, e, f) {var i, j, k, l, m, n = "function" == typeof a && a, o =! F && g (a = n.selector || a) (J = o [0] = o [0] .slice (0), j.length> 2 && "ID" === (k = j [0 ]) Type && c.getById && 9 === b.nodeType && p && d.relative [j [1] .type]) {if (b = (d.find.ID (k.matches [0] .replace (ba, ca), b ) B = b.parentNode), a = a.slice (j.shift (). Value.length)} i = W.needsContext.test () A)? 0: j.length, enquanto (i -) {if (k = j [i], d.relative [l = k.type] (B.parentNode) || b))) {if (j.splice (b.parentNode) (F, b), a = f.length && qa (j) ,! a) return Happly (e, f), e; ! P, e,! B || _.test (a) && oa (b.parentNode) || b), e}, c.sortStable = u.split (""). Sort (B) .join (" ),), Ia (function (a) {return 1 & a.compareDocumentPosition (n.createElement ("div"))) === u, c.detectDuplicates =! L, m (), c.sortDetached = A) {return a.innerHTML = "<a href='#'> </a>", "#" === a.firstChild.getAttribute ("href")}) || ja ("type | href | (A, b, c) {return c? Void 0: a.getAttribute (b, "type" === b.toLowerCase ()? 1: 2)}, c.attributes && ia (function (A) {return a.innerHTML = "<input />", a.firstChild.setAttribute ("value", ""), "" === a.firstChild.getAttribute ("value")} ("Valor", função (a, b, c) {return c || "input"! == a.nodeName.toLowerCase ()? Void 0: a.defaultValue}), ia (função (a) {return null == a.getAttribute ("disabled")}) || ja (K, função (a, b, c) {var d; retorno c? Void 0: a [b] ===! 0? B.toLowerCase ) :( d = a.getAttributeNode (b)) && d.specified? D.value: null}), fa} (a); n.find = t, n.expr = t.selectors, n.expr [ "] = N.exp.pseudos, n.uniqueSort = n.unique = t.uniqueSort, n.text = t.getText, n.isXMLDoc = t.isXML, n.contains = t.contains; var u = function ( A, b, c) (= = a.nodeType) if (1 === a.nodeType) (A, b) {for (var c = []; a; a = a.nextSibling ) 1 === a.nodeType && a! == b && c.push (a); retorno c}, w = n.expr.match.needsContext, x = / ^ <([\ w -] +) \ s * \ / (?: <\ / \ 1> |) $ /, y = / ^. [^: # \ [\.,] * $ /; função z (a, b, c) (A, d) {return! B.call (a, d, a)! == c}); if (b.nodeType) return n.grep (a , Função (a) {return a === b! == c}); if ("string" == typeof b) {if (y.test (b)) retorno n.filter (b, a, c) B = n.filter (b, a)} return n.grep (a, função (a) {return n.inArray (a, b) , B, c) {var d = b [0]; retorno c && (a = ": não (" + a + ")"), 1 === b.length && 1 === d.nodeType? N.find.matchesSelector (D, a)? [D]: []: n.find.matches (a, n.grep (b, função (a) {return 1 === a.nodeType}))}, n.fn.extend ({Find: função (a) {var b, c = [], d = isto, e = d.length; if ("string"! = Typeof a) return this.pushStack (n (a) .filter () Para (b = 0; e> b; b ++) se (n.contains (d [b], this)) return! (A, d [b], c), retorno c = this.pushStack (e> 1? N.unique (c): c), c.selector = this.selector? This.selector + "" + a: a , C}, filter: function (a) {return this.pushStack (z (this, a || [] ,! 1))}, não: function (a) {return this.pushStack (z (this, a | (), É: function (a) {return! Z (this, "string" == typeof a && w.test (a)? N (a): a || [] ,! 1 ) .length}}); var A, B = / ^ (?: \ S * (<[W] C = n.fn.init = função (a, b, c) {var e, f; if (! A) retorna this; if (c = c || A, "string" == typeof a) E = "<" === a.charAt (0) && ">" === a.charAt (a.length-1) && a.length> = 3? [Null, a, null]: B.exec (A): this.constructor (b) .find (a); if (e) (b) [1]) {if (b = b instância de n? B [0]: b, n.merge (isto, n.parseHTML (e [1], b && b.nodeType? B.ownerDocument || b: d,! 0 ), X.test (e [1]) && n.isPlainObject (b)) para (e em b) n.isFunção (this [e]) this [e] (b [e]): this.attr (F = d.getElementById (e [2]), f && f.parentNode) {if (f.id! == e [2]) retorna A.find (a) This.length = 1, this [0] = f} return this.context = d, this.selector = a, this} return a.nodeType? (This.context = this [0] = a, this.length = 1, this): n.isFunction (a)? "Undefined"! = Typeof c.ready? C.ready (a): a (n) :( void 0! == a.selector && (this.selector = a. Selector, this.context = a.context), n.makeArray (a, this))}; C.prototype = n.fn, A = n (d); var D = / ^ (?: parents | prev (? : Até | Todos)) /, E = {children:! 0, contents:! 0, next:! 0, prev: | 0}; n.fn.extend ({has: função (a) {var b, c = N (a, this), d = c.length; retorna this.filter (function () {for (b = 0; d> b; b ++) if (n.contains (this, c [b] (A, b) {para (var c, d = 0, e = este comprimento, f = [], g = w.test (a) || "string"! = (C = this [d]; c && c! == b; c = c.parentNode) if (c.nodeType < 11 && (g ?.index (c)> - 1: 1 === c.nodeType && n.find.matchesSelector (c, a))) {f.push (c);(), Index: function (a) {return a? "String" == typeof a? N.inArray (this [0] , N (a)): n.inArray (a.jquery? A [0]: a, this): this [0] && this [0] .parentNode? This.first (). PrevAll (). }, Add: function (a, b) {return this.pushStack (n.uniqueSort (n.merge (this.get (), n (a, b))))}, addBack: function (a) {return this .add (null == a? This.prevObject: this.prevObject.filter (a))}}); função F (a, b) {do a = a [b], enquanto (a && 1! == a.nodeType ), Return a} n.each (): função (a) {return u (a, {a) {parent: função (a) {var b = a.parentNode; return b && 11! == b.nodeType? "ParentNode")}, parentsUntil: function (a, b, c) {retorno u (a, "parentNode", c)}, Função (a) {return F (a, "previousSibling")}, nextAll: função (a) {return u (a, "nextSibling" }, NextUntil: function (a, b, c) {retorno u (a, "nextSibling", c)}, prevUntil: (A) {return v (a.parentNode || {}), firstChild, a)}, children: função (a) {return v (a.firstChild)}, conteúdo: function (a) {return N.nodeName (a, "iframe")? A.contentDocument || a.contentWindow.document: n.merge ([], a.childNodes)}}, função (a, b) {n.fn [a] = Função (c, d) {var e = n.map (isto, b, c); return "Até"! == a.slice (-5) && (d = c), d && "string" == typeof d && (E = n.filtro (d, e)), this.length> 1 && (E [a] || (e = n.uniqueSort (e)), D.test (a) && (e = e.reverse () () () () () () () () () ())) , Função (a, c) {b [c] =! 0}), b} n.Callbacks = função (a) {a = "string" == tipo de um H (a): n.extend ({ , A), var b, c, d, e, f = [], g = [], h = -1, i = função () {para (e = a.once, d = b = (C [0], c [1]) ===! 1 && a. (C = 1), b =! 1, e && (f = c? []: "")}, J = {add: Função () {return f && (c &&! B && (h = f.length-1, g.push (c)), função d (b) {n.each (b, function (b, c) C)? A.unique && j.has (c) || ​​f.push (c): c && c.length && "string"! == n.type (c) && d (c)}) )), Isto}, remove: function () {return n.each (argumentos, função (a, b) {var c; enquanto ((c = n.inArray (b, f, c) .splice (c, 1), h> = c && h -}), isto}, tem: function (a) {return a? N.inArray (a, f)> - 1: f.length> 0} : Function () {return f && (f = []), this}, disable: function () {return e = g = [], f = c = "", this} }, Lock: function () {return e =! 0, c || j.disable (), this}, bloqueado: function () {return !! e}, fireWith: função (a, c) {return e | (C = c || [], c = [a, c.slice? C.slice (): c], g.push (c), b || i ()), ) {Return j.fireWith (this, arguments), this}, fired: function () {return | d}}; return j}, n.extend ({Diferido: function (a) {var b = [[ Resolver "," cancelar "," rejeitar "," cancelar "," cancelar "," cancelar " , "Progresso", n.Callbacks ("memory")]], c = "pendente", d = {estado: function () {return c}, sempre: function () {return e.done (Argumento)}, então: function () {var a = argumentos; return n.Deferred (função (c) {n.each (b, função (b, f) {var g = n.isFunction (a [ B]) && a [b]; e [f [1]] (função () {var a = g && g.apply (isto, argumentos); a && n.isFunction (a.promise)? (C.reject): c [f [0] + "With"] (isto === d? C.promise (): this, g? [A]: (), Promessa: função (a) {return null! = A? N.extend (a, d): d}}, e = {}; return D.pipe = d.then, n.each (b, função (a, f) {var g = f [2], h = f [3]; d [f [1]] = g.add, h && g. [F [0]] = função () {return e [f [0] + "With"] (isto === e? D: isto, argumentos), isto}, e [f [0] + "Com"] = g.fireWith} A && a.call (e, e), e}, quando: função (a) {var b = 0, c = e.call (argumentos), d = c.length, f = 1! == d || a && n. Função (a, b, c) {função de retorno (d) {b [a] = this Função (a.promise)? D: 0, g = 1 === f? A: n.Deferred , C [a] = arguments.length> 1? E.call (argumentos): d, c === i? G.notifyWith (b, c): - f || g.resolveWith (b, c)} (D), j = new Array (d), k = new Array (d), d> b, b ++) c [b] && n.isFunction (c [b] .promise)? C [b] .promise (). Progress (h (b, j, i) ): - f; return f || g.resolveCom (k, c), g.promise ()}}); var I; n.fn.ready = função (a) {return n.ready.promise () .done (a), this}, n.extend ({isReady:! 1, readyWait: 1, holdReady: function (a) {a? N.readyWait ++: n.ready ) {(A ===! 0? - n.readyWait: n.isReady) || (n.isReady =! 0, a! ==! 0 && - n.readyWait> 0 || (I.resolveWith D, [n]), n.fn.triggerHandler && (n (d) .triggerHandler ("pronta"), n (d) .off ("pronta")) (D.removeEventListener ("DOMContentLoaded", K), a.removeEventListener ("carregar", K)) :( d.detachEvent ("onreadystatechange", K), a.detachEvent ("onload", K))} Função K () {(d.addEventListener || "load" === a.event.type || "complete" === d.readyState) && (J (), n.ready ())} n.ready .promise = function (b) {if (! I) se (I = n.Deferred (), "complete" === d.readyState || "loading"! == d.readyState &&! D.documentElement.doScroll) (D.addEventListener) d.addEventListener ("DOMContentLoaded", K), a.addEventListener ("carregar", K); else {d.attachEvent ("onreadystatechange", K) , A.attachEvent ("onload", K); var c =! 1; try {c = null == a.frameElement && d.documentElement} catch (e) {} c && c.doScroll &&! Function f () {if .isReady) {try {c.doScroll ("esquerda")} catch (b) {return a.setTimeout (f, 50)} J (), n.ready ()}} ), N.ready.promise (); var L; para (L em n (l)) break; l.ownFirst = "0" === L, l.inlineBlockNeedsLayout =! 1, n (function () C = d.getElementsByTagName ("body") [0], c && c.style && (b = d.createElement ("div"), e = d.createElement ("div"), e .style.cssText = "position: absolute; border: 0; width: 0; height: 0; top: 0; left: -9999px", c.appendChild (e) .appendChild (b), "undefined"! B.style.zoom && (b.style.cssText = "display: inline; margin: 0; border: 0; padding: 1px; width: 1px; zoom: 1"; l.inlineBlockNeedsLayout = a = 3 === b. OffsetWidth, a && (c.style.zoom = 1)), c.removeChild (e))}, function () {var a = d.createElement ("div"); l.deleteExpando =! 0; try {delete A.test} catch (b) {l.deleteExpando =! 1} a = null} (); var M = função (a) {var b = n.noData [(a.nodeName + "") .toLowerCase () , C = + a.nodeType || 1; return 1! == c && 9! == c ?! 1:! B || b! ==! 0 && a.getAttribute ("classid") === b}, N = / ^ (?: \ {[\ W \ W] * \} | \ [\ W \ C) {if (void 0 === c && 1 === a.nodeType) {var d = "data-" + b.replace (O, "- $ 1"). ToLowerCase (); if (c = a.getAttribute (D), "string" == typeof c) {try {c = "true" === c?! 0: "false" === c ?! 1: "null" === c? C + c = n + c: N.test (c)? N.parseJSON (c): c} catch (e) {} n.data (a, b, c)
} Retornar c} função Q (a) {var b; para (b em a) if (("data"! == b ||! N.isEmptyObject (a [b])) && "toJSON"! == b ) Return! 1; return! 0} função R (a, b, d, e) {if (M (a)) {var f, g, h = n.expando, i = a.nodeType, j = i? N.cache: a, k = i? A [h]: a [h] && h; se (k && j [k] && (e || j [k] .data) String "! = Typeof b) retorno k || (k = i? A [h] = c.pop () || n.guid ++: h), j [k] || (j [k] = i? }: {ToJSON: n.noop}), "object"! = Typeof b && "function"! = Typeof b || (e? J [k] = n.extend (j [k], b) ] .data = n.extend (j [k] .data, b)), g = j [k], e || (g.data || (g.data = {}), g = g.data) , Void 0! == d && (g [n.camelCase (b)] = d), "string" == typeof b (f = g [b], null == f & B)])): f = g, f}} função S (a, b, c) {if (M (a)) {var d, e, f = a.nodeType, A, h = f? A [n.expando]: n.expando; se (g [h]) {if (b && (d = c?G [h]: g [h] .data)) {n.isArray (b)? B = b.concat (n.map (b, n.camelCase)): b in d? B = [b] :( B = n.camelCase (b), b = b em d? [B]: b.split ("")), e = b.length, enquanto (e -) delete d [b [e]]; (C (q) :! n.isEmptyObject (d)) return} (c || (delete g [h] .data, Q (g [h]))) && (f? N.cleanData G] = null = 0)}}} n.extend ({cache: {}, noData: {" Applet ":! 0," embed ":! 0," objeto ":" clsid: D27CDB6E-AE6D-11cf-96B8-444553540000 "}, hasData: function (a) {return a = a.nodeType? N.cache [ A [n.expando]]: a [n.expando],! A &&! Q (a)}, data: function (a, b, c) (A, b) {return S (a, b)}, _ dados: função (a, b, c) {retorno R (a, b, c, S (a, b,! 0)}), n.fn.extend ({data: função (a, b) {var c, d, e, f = isto [0], g = f && f.attributes; (Void 0 === a) {if (this.length && (e = n.data (f), 1 === f.nodeType &&! N._data (f, "parsedAttrs"))) {c = g.length , Enquanto que (c-) g [c] && (d = g [c] .name, 0 === d.indexOf ("data-") && (d = n.camelCase (d.slice (5)) (F, d, e [d])); n._data (f, "parsedAttrs",! 0)} return e} return "objeto" == typeof a? .data (this, a)}): arguments.length> 1? This.each (função () {n.data (isto, a, b)}: f? P (f, a, n.data (A) {return this.each (function () {n.removeData (this, a)})}}), n.extend ({queue: function (a, B, c) {dt = n._data (a, b), c && (! D || n.isArray (c) ? D = n._data (a, b, n.makeArray (c)): d.push (c)), d || []): void 0}, dequeue: função (a, b) (A, b), g = function () {n (f), f = n.queja (a, b), d = c.length, e = c.shift .dequeue (a, b)}; "inprogress" === e && (e = c.shift (), d -), e && ("fx" === b && c.unshift ("inprogress"). (A, b) {var c = b + "queueHooks"; return n._data (a, c) || n._data (a, c, {empty: n.Callbacks ("uma vez memória"). Add (function () {n._removeData (a, b + "queue"), n._removeData (a, c)} )}, N.fn.extend ({fila: função (a, b) {var c = 2; retorno "string"! = Typeof a && (b = a, a = "fx", c-- ), Arguments.length <c? N.queue (this [0], a): void 0 === b? Isto: this.each (function () {var c = n.queue (this, a, b) (= A), () (), () () () () () () () () () () () (Função () {n.dequeue (this, a)})}, clearQueue: função (a) {return this.queue (a || "fx", []) D = 1, e = n.Deferido (), f = isto, g = isto.length, h = função () {- d || e.resolveCom (f, [f]); "= = A, a = void 0), a = a ||" fx ", enquanto que (g -) c = n._data (f [g], a +" queueHooks "), c && c. Vazio && (d ++, c.empty.add (h)); retorno h (), e.promise (b)}}), função () {var a; l.shrinkWrapBlocks = function () {if (null! ) Return a; a =! 1; var b, c, e; return c = d.getElementsByTagName ("corpo") [0], c && c.style? (B = d.createElement .createElement ("div"), e.style.cssText = "position: absolute, border: 0; width: 0; height: 0; top: 0; left: -9999px", c.appendChild (e) .appendChild B), "undefined"! = Typeof b.style.zoom && (b.style.cssText = "- webkit-box-sizing: content-box; -moz-box-sizing: content-box; Caixa, display: bloco, margem: 0, limite: 0, preenchimento: 1px; largura: 1px; zoom: 1 ", b.appendChild (d.createElement (" div ")). Style.width =" 5px " = 3! == b.offsetWidth), c.removeChild (e), a): void 0}} (); var T = / [+ -]? (?: \ D * \. |) : [EE] [+ -]? \ D + |) /. Source, U = new RegExp ("^ (?: ([+ -]) "," I "), V = [" Top "," Direita "," Inferior "," Esquerda "], W = função (a, b) {return a = b || a," none "=== N.css (a, "display") ||! N.contains (a.ownerDocument, a)}; função X (a, b, c, d) {var e, f = 1, g = 20, h = D = função () {return d.cur ()}: função () {return n.css (a, b, "")}, i = h (), j = c && c [3] || (n.cssNumber (N.cssNumber [b] || "px"! == j && + i) && U.exec (n.css (a, b)); if (k && k [3]! == j) j = j || k [3], c = c || [], k = + i || 1; do f = f || ".5", k / = f , N.style (a, b, k + j), enquanto que (f = f (h = f) + C [2], d && (d.unit = j, d.start = k, d.end = E) var = função (a, b, c, d, e, f, g) {var h = 0, i = a.length, j = null == c; if ("object" == n.tipo (c)) {e = 0 0 para (h em c) Y (a, b, h, c [h], 0, f, g)} else if (void 0! D = b, b = função (d = 0), j = (0) A, b, c) {retorno j.call (n (a), c)})), b)) para (| i> h; h ++) b (a [h], c, g? D: d. (A [h], h, b (a [h], c))); retorno e? A: j? B.call (a) Z = / ^ (?: checkbox | rádio) $ / i, $ = / <([\ w: -] +) /, _ = / ^ $ | \ / (?: java | ecma) script / i, aa ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,, (A) {var b = ba.split ("|"), c = a.createDocumentFragment (); se (c.createElement) while (b .length) c.createElement (b.pop ()); return c}! Function () {var a = d.createElement ("div"), b = d.createDocumentFragment (), c = d.createElement ("input "); A.innerHTML =" <link /> <table> </ table> <a href='/a'> a </a> <input type = 'checkbox' /> ", l.leadingWhitespace = 3 = == a.firstChild.nodeType, l.tbody =! A.getElementsByTagName ("tbody"). Comprimento, l.htmlSerialize = !! a.getElementsByTagName ("link"). Length, l.html5Clone = "<: nav> </: Nav> "! == d.createElement (" nav "). CloneNode (! 0) .outerHTML, c.type =" checkbox ", c.checked =! 0, b.appendChild (c), l. AppendChecked = c.checked, a.innerHTML = "<textarea> x </ textarea>", l.noCloneChecked = !! a.cloneNode (! 0) .lastChild.defaultValue, b.appendChild (a), c = d. CreateElement ("input"), c.setAttribute ("type", "radio"), c.setAttribute ("checked", "checked"), c.setAttribute ("name", "t"), a.appendChild C), l.checkClone = a.cloneNode (! 0) .cloneNode (! 0) .lastChild.checked, l.noCloneEvent = !! a.addEventListener, a [n.expando] = 1, l.attributes =! A ,,,,,,,,,,,,,,,,,,,,,,,, ], Área: [1, "<map>", "</ map>"], param: [1, "<object>", "</ object>"] ], Col: [2, "<table>", "</ table>"], tr: [2, "<table> <tbody> <Tbody> </ tbody> <colgroup> "," </ colgroup> </ table> "], td: [3, <table> <tbody> <tr> </ Table> "], _ default: l.htmlSerialize? [0," "," "]: [1," X <div> "," </ div> "}; da.optgroup = da.option, Da.t = da.tfoot = da.tcolo = da.caption = da.thead, da.th = da.td; função ea (a, b) {var c, d, e = 0, f = "undefined" ! = Typeof a.getElementsByTagName? A.getElementsByTagName (b || "*"): "undefined"! = Typeof a.querySelectorAll? A.querySelectorAll (b || "*"): void 0; if (! F) for (F = [], c = a.childNodes || a; null! = (D = c [e]); e ++)! B || n.nodeName (d, b)? F.push (d): n (F, ea (d, b)); retorno void 0 === b || b && n.nodeName (a, b)? N.merge ([a], f): f} função fa (a, b) ) {Para (var c, d = 0; null! = (C = a [d]); d ++) n._data (c, "globalEval",! B || n._data (b [d], globalEval ")) Var = ga = / & lt; w +; /, ha = / <tbody / i; função ia (a) {Z.test (a.type) && } Função ja (a, b, c, d, e) {para (var f, g, h, i, j, k, m, o = a.length, p = ca (b) (G = a [r], g || 0 === g) if ("objeto" === n.tipo (g)) n.merge (q, g .nodeType? [G]: g); else se (ga.test (g)) {i = i || p.appendChild (b.createElement ("div")), j = ($. Exec (g) | | ["", ""]) [1] .toLowerCase (), m = da [j] || da._default, i.innerHTML = m [1] + n.htmlPrefilter (g) + m [2] F = m [0]; enquanto (f-) i = i.lastChild; if (! L.leadingWhitespace && aa.test (g) && q.push (b.createTextNode (aa.exec (g) [0])) (1) || ha.test (g)? 0: i: i .firstChild, f = g && g.childNodes.length; enquanto (f-) n.nodeName (k = g.childNodes [f], "tbody") &&! K.childNodes.length && g.removeChild (k)} n.merge (I.firstChild) i.removeChild (i.firstChild); i = p.lastChild} else q.push (b.createTextNode (g)); i && p (q, i.childNodes), i.textContent = (G, q), r = 0, enquanto (g = q [r ++]) se (d && n.inArray (g, d) > -1) e && e.push (g); se h = n.contains (g.ownerDocument, g), i = ea (p.appendChild (g), "script"), h && fa (i) (G = i [f ++]). Teste (g.type || "") && c.push (g)} return i = nulo, p}! Função () {var b, c, E = d.createElement ("div"); para (b em {submit:! 0, change:! 0, focusin:! 0}) c ​​= "on" + b, (l [b] = c em a) || (e.setAttribute (c, "t"), l [b] = e.attributes [c] .expando ===! 1); e = null} (); var ka = / ^ | Select | textarea) $ / i, la = / ^ key /, ma = / ^ (?: mouse | ponteiro | contextmenu | arrastar | soltar) | click /, na = / ^ (?: focusinfocus | focusoutblur) Função de função () {função de retorno de função) () () {) Return d.activeElement} catch (a) {}} função sa (a, b, c, d, e, f) {var g, h; if ("objeto" == typeof b) {"string"! (D = d || c, c = nulo 0), para (h em b) sa (a, h, c, d, b [h], f) (E = c, d = c = void 0): null == e && ("string" == tipo de c? E = (a) {return n (). Off (1) e = (1) e = qa; A), g.apply (isto, argumentos)}, e.guid = g.guid || (g.guid = n.guid ++)), a.each (function () {n.event.add (this, b , E, d, c)})} n.event = {global: {}, adicionar: função (a, b, c, d, e) M, o, p, q, r = n.data (a), se (r) {c.handler && (i = c, c = i.handler, e = i.selector), c.guid || (K = r.handle) || (k = r.handle = função (a) {return (g = r.events) "Undefined" == typeof n || a && n.event.triggered === a.tipo? Void 0: n.event.dispatch.apply (k.elem, arguments)}, k.elem = a), b = B || ""), correspondente (G) || [""], h = b.length; enquanto (h-) f = oa.exec (b [h] F [1], p = (f [2] || ""). Split ("."). Sort (), o && (j = n.event.special [o] ? J.delegateType: j.bindType) || o, j = n.event.special [o] || {}, l = n.extend ({type: o, origType: q, data: d, handler: c , Guid: c.guid, selector: e, needsContext: e && n.expr.match.needsContext.test (e), namespace: p.join (".")}, I), (m = g [o]) | | (M = g [o] = [], m.delegateCount = 0, j.setup && j.setup.call (a, d, p, k)! ==! 1 || (a.addEventListener? A.addEventListener O, k,! 1): a.attachEvent && a.attachEvent ("on" + o, k))), j.add && (j.add.call (a, l), l.handler.guid || (l. (M.delegateCount ++, 0, l): m.push (l), n.event.global [o] =! 0); a = null}} , Remove: função (a, b, c, d, e) {var f, g, h, i, j, k, l, m, o, p, q, r = n.hasData (a) && n._data (A); se (r && (k = r.events)) (b = (b || ""). Correspondência (G) || [""], j = b.length; (H = oa.exec (b [j]) || [], o = q = h [1], p = (h [2] || " O) {l = n.event.special [o] || {}, o = (d? L.delegateType: l.bindType) || o, m = k [o] || [], h = 2] && new RegExp ("(^ | \\.)" + P.join ("\\. (?:. * \\. |)") = M.length; enquanto (f -) g = m [f],! E && q! == g.origType || c && c.guid! == g.guid || h &&! H.test (g.namespace) | | D && d! == g.selector && ("**"! == d ||! G.selector) || (m.splice (f, 1), g.selector && m.delegateCount -, l.remove && l.remove. Call (a, g)); i &&! M.length && (l.teardown && l.teardown.call (a, p, r.handle)! ==! 1 || n.removeEvent (a, o, r.handle) Delete k [o]) else para (o em k) n.event.remove (a, o + b [j], c, d,! 0); n.isEmptyObject (k) && (delete r.handle, N._removeData (a, "eventos"))}}, gatilho: função (b, c, e, f) {var g, h, i, j, l, m, , Q = k.call (b, "type")? B.type: b, r = k.call (b, "namespace")? B.namespace.split ("."): = M = e = e || d, 3! == e.nodeType && 8! == e.nodeType &&! Na.test (q + n.event.triggered) && (q.indexOf (".")> - 1 && R = q.split ("."), Q = r.shift (), r.sort ()), h = q.indexOf (":") <0 && "on" + q, b = b [n. Expando]? B: new n.Event (q, "objeto" == typeof b && b), b.isTrigger = f? 2: 3, b.namespace = r.join ("."), B.rnamespace = b. Namespace? New RegExp ("(^ | \\.)" + R.join ("\\. (?:. * \\. |)") + "(\\. | $)"): Null, b .result = void 0, b.target || (b.target = e), c = null == c? [B]: n.makeArray (c, [b]), l = n.event.special [q ] || {}, f ||! L.trigger || l.trigger.apply (e, c)! ==! 1)) {if (! F &&! L.noBubble &&! N.isWindow (e)) { Para (j = l.legateType || q, na.test (j + q) || (i = i.parentNode); i; i = i.parentNode) p.push (i), m = i; m = == (e.ownerDocument || d) && p.push (m.defaultView || m.parentWindow || a)} o = 0; while ((i = p [o ++]) &&! B.isPropagationStopped ()) b .type = o> 1? J: l.bindType || q, g = (n._data (i, "eventos") || {}) [b.type] && n._data (i, G && g.apply (i, c), g = h && i [h], g && g.apply && M (i) && (b.result = g.apply (i, c), b.result ===! 1 && b.preventDefault ; If (b.type = q,! F &&! B.isDefaultPrevented () && (! L._default || l._default.apply (p.pop (), c) ===! 1) && M (e) && h && e [Q] &&! N.isWindow (e)) {m = e [h], m && (e [h] = null), n.event.triggered = q; try {e [q] ) {} N.event.triggered = void 0, m && (e [h] = m)} return b.result}}, disp: function (a) {a = n.event.fix (a) C, d, f, g, h = [], i = e.call (argumentos), j = (n.data (this, "events") || {}) K = n.event.special [a.type] || {}; if (i [0] = a, a.delegateTarget = this,! K.preDispatch || k.preDispatch.call (this, a)! = (= F = h [b ++]) &&! A.isPropagationStopped ()) {a.currentTarget = f (h = n.event.handlers.call (this, a, j) .elem, c = 0; while ((g = f.handlers [c ++]) &&! A.isImmediatePropagationStopped ()) a.rnamespace &&! A.rnamespace.test (g.namespace) || (a.handleObj = g, A.data = g.data, d = ((n.event.special [g.origType] || {}) handle || g.handler) .apply (f.elem, i), void 0! == D && (a.result = d) ===! 1 && (a.preventDefault (), a.stopPropagation ()))} return k.postDispatch && k.postDispatch.call (this, a), a.result}}, handlers: Função (a, b) {var c, d, e, f, g = [], h = b.delegateCount, i = a.target; se (h && i.nodeType && ("click"! == a.type || IsNaN (a.button) || a.button <1)) para (; i! = This; i = i.parentNode || this) if (1 === i.nodeType && (i.disabled! ==! 0 || "click"! == a.tipo)) {for (d = [], c = 0; h> c; c ++) f = b [c], e = f.selector + "", void 0 == = D [e] && (d [e] = f.needsContext? N (e, this) .index (i)> - 1: n.find (e, this, null, [i] [E] && d.push (f); d.length && g.push ({elem: i, manipuladores: d})} return h <b.length && g.push ({elem: this, handlers: b.slice (h)} ), G}, fix: função (a) {if (a [n.expando]) retorna a; var b, c, e, f = a.tipo, g = a, h = this.fixHooks [f]; H || (this.fixHooks [f] = h = ma.test (f)? This.mouseHooks: la.test (f)? This.keyHooks: {}), e = h.props? This.props.concat (H.props): this.props, a = new n.Event (g), b = e.length; enquanto (b -) c = e [b], a [c] = g [c]; A.target || (a.target = g.srcElement || d), 3 === a.target.nodeType && (a.target = a.target.parentNode), a.metaKey = !! a.metaKey, h .filter? H.filter (a, g): a}, adereços: "altKey bolhas cancelável ctrlKey currentTarget detalhe eventPhase metaKey relatedTarget shiftKey meta timeStamp ver que" .split (""), fixHooks: {}, keyHooks: {props: "Char charCode key keyCode" .split (""), filter: function (a, b) {return null == a.which && (a.which = null! = B.charCode? B.charCode: b.keyCode) A}}, mouseHooks: {props: "botão botões clientX clientY fromElement offsetX offsetY páginaX pageY screenX screenY toElement" .split (""), filtro: função (a, b) {var c, e, f, g = b. Botão, h = b.fromElement; return null == a.pageX && null! = B.clientX && (e = a.target.ownerDocument || d, f = e.documentElement, c = e.body, a.pageX = b. ClientX + (f && f.scrollLeft || c && c.scrollLeft || 0) - (f && f.clientLeft || c && c.clientLeft || 0), a.pageY = b.clientY + (f && f.scrollTop || c && c.scrollTop || 0) (F && f.clientTop || c && c.clientTop || 0)), a.relatedTarget && h && (a.relatedTarget = h === a.target?b.toElement:h),a.which||void 0 === g (A.which = 1 & g? 1: 2 & g? 3: 4 & g? 2: 0), a}}, special: {load: {noBubble: } == ra () && this.focus) try {return this.focus () ,! 1} catch (a) {}}, delegateType: "focusin"}, blur: {trigger: function () = () () ()), Clique em: {trigger: function () {return n.nodeName (this, "input") && "checkbox" === this.type && this.click? (This.click () ,! 1): void 0}, _ default: função (a) {return n.nodeName (a.target, "a")}} , Antes de descarregar: {postDispatch: função (a) {void 0! == a.result && a.originalEvent && (a.originalEvent.returnValue = a.result)}}}, simular: função (a, b, c) {var d = N.extend (novo n.Event, c, {tipo: a, isSimulated:! 0}); n.event.trigger (d, null, b), d.isDefaultPrevented () && c.preventDefault ()}}, n .removeEventListener (a, b, c) {a.removeEventListener && a.removeEventListener (b, c)}: função (a, b, c) {var d = "on" + b; a.detachEvent && "Undefined" == typeof a [d] && (a [d] = null), a.detachEvent (d, c))}, n.Event = função (a, b) {return this instanceof n.Event? A && a.type? (This.originalEvent = a, this.type = a.type, this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented && a.returnValue ===! 1 pa: qa): this (This, b), this.timeStamp = a && a.timeStamp || n.now (), void (this [n.expando] =! 0)): new n.Event (a, B)}, n.Event.prototype = {construtor: n.Event, isDefaultPrevented: qa, isPropagationStopped: qa, isImmediatePropagationStopped: qa, preventDefault: function () {var a = this.originalEvent; this.isDefaultPrevented = pa, a && A.preventDefault? A.preventDefault (): a.returnValue =! 1)}, stopPropagation: function () {var a = this.originalEvent; this.isPropagationStopped = pa, a &&! This.isSimulated && (a.stopPropagation && a.stopPropagation ), A.cancelBubble =! 0)}, stopImmediatePropagation: function () {var a = this.originalEvent; this.isImmediatePropagationStopped = pa, a && a.stopImmediatePropagation && a.stopImmediatePropagation (), this.stopPropagation ()}}, n.each ( {Mouseenter: "mouseover", mouseleave: "mouseout", pointerenter: "pointerover", pointerleave: "pointerout"}, função (a, b) {n.event.special [a] = {delegateType: b, bindType: b , Handle: função (a) {var c, d = isto, e = a.relatedTarget, f = a.handleObj; return e && (e === d || n.contains (d, e)) || (a .type = f.origType, c = f.handler.apply (isto, argumentos), a.type = b), c}}}), l.submit || (n.event.special.submit = {setup: Function () {return n.nodeName (this, "form") ?! 1: void n.event.add (this, "click._submit keypress._submit", função (a) {var b = a.target, c = N.nodeName (b, "input") || n.nodeName (b, "button")? N.prop (b, "form"): void 0; c &&! N._data (c, "submit") && (n.event.add (c, "submit._submit", função (a) {a._submitBubble =! 0}, n._data (c, "submit",! 0))})}, postDispatch: Função (a) {a._submitBubble && (delete a._submitBubble, this.parentNode &&! A.isTrigger && n.event.simulate ("submit", this.parentNode, a))}, teardown: function () {return n.nodeName This, "form") ?! 1: void n.event.remove (this, "._ submit")}, l.change || (n.event.special.change = {setup: function () {return Ka.test (this.nodeName)? ("Checkbox"! == this.type && "radio"! == this.type || (n.event.add (this, "propertychange._change", function (a) { "Checked" === a.originalEvent.propertyName && (this._justChanged =! 0)}), n.event.add (this, "click._change", função (a) {this._justChanged &&! A.isTrigger && 1): void n.event.add (isto, "beforeactivate._change", função (a) {var B = a.target; ka.test (b.nodeName) &&! N._data (b, "change") && (n.event.add (b, "change._change", função (a) {! This. ParentNode || a.isSimulated || a.isTrigger || n.event.simulate ("change", this.parentNode, a)}), n._data (b, "change",! 0))} Handle: function (a) {var b = a.target; return this! == b || a.isSimulated || a.isTrigger || "radio"! == b.type && "checkbox"! == b.type ? A.handleObj.handler.apply (isto, argumentos): void 0}, teardown: function () {return n.event.remove (this, "._ change") ,! ka.test (this.nodeName)}} ), L.focusin || n.each ({focus: "focusin", blur: "focusout"}, função (a, b) {var c = função (a) {n.event.simulate (b, a. Target, n.event.fix (a))}; n.event.special [b] = {setup: function () {var d = this.ownerDocument || this, e = n._data (d, b); E || d.addEventListener (a, c,! 0), n._data (d, b, (e || 0) +1)}, teardown: function () {var d = this.ownerDocument || this, E = n._data (d, b) -1; e? N._data (d, b, e) :( d.removeEventListener (a, c,! 0), n._removeData (d, b) ), N.fn.extend ({on: função (a, b, c, d) {retorno sa (isto, a, b, c, d) (A, b, c, d, 1)}, off: função (a, b, c) {var d, e; if (a && a.preventDefault && a.handleObj) return d = a.handleObj, n (A.legateTarget) .off (d.namespace? D.origType + "." + D.namespace: d.origType, d.selector, d.handler), this; if ("object" == typeof a) {for (E em a) thisff (e, b, a [e]); return this} return b! ==! 1 && "function"! = Typeof b || (c = b, b = void 0) ===! 1 && (c = qa), this.each (function () {n.event.remove (isto, a, c, b)}), trigger: function (a, b) {return this.each (Função () {n.event.trigger (a, b, this)})}, triggerHandler: função (a, b) {var c = this [0]; return c? N.event.trigger (a, b (C: 0): void 0}}); var ta = / jQuery \ d + = "(?: null | \ d +)" / g, ua = new RegExp \\ s />] "," i "), va = / <(? | Area | br | col | embed | hr | img | input | [^>] *) \ /> Gi, wa = / <script | <estilo | <link / i, xa = / checked \ s * (?: [^ =] | = \ S * .checked.) / I, ya = / ^ true \ / (. *) /, Za = / ^ \ s * <! (?: \ [CDATA \ [| -) | (?: \] \ S * $ / g, Aa = ca (d), Ba = Aa.appendChild (d.createElement ("div")); função Ca (a, b) {return n.nodeName && n. NodeName (11! == b.nodeType? B: b.firstChild, "tr")? A.getElementsByTagName ("tbody") [0] || a.appendChild (a.ownerDocument.createElement ("tbody")): A} função Da (a) {return a.type = (null! == n.find.attr (a, tipo)) + "/" + a.tipo, a} função Ea (a) {var b = Ya.exec (a.type); return b? A.type = b [1]: a.removeAttribute ("type"), a} função Fa (a, b) {if (1 === b.nodeType && n (H) {delete g.handle, h = f.data (a)) {var c, d, e, f = n.data (a), g = n.data (b, f) G.events = {}, para (c em h) para (d = 0, e = h [c] .length; e> d; d ++) n.event.add (b, c, h [c] [d ] G.data && (g.data = n.extend ({}, g.data))}} função Ga (a, b) {var c, d, e; if (1 === b.nodeType) {If (c = b.nodeName.toLowerCase () ,! l.noCloneEvent && b [n.expando]) {e = n._data (b); para (d em e.events) n.removeEvent (b, d, e (B) .text = a.text, Ea (b)): "objeto" === c? (B.parentNode && (b.outerHTML = a.outerHTML), l.html5Clone && a.innerHTML &&! N.trim (b.innerHTML) && (b.innerHTML = a.innerHTML)): "input" == = C && Z.test (a.type)? (B.defaultChecked = b.checked = a.checked, b.value! == a.value && (b.value = a.value)): "option" === c ? B.defaultSelected = b.selected = a.defaultSelected: "input"! == c && "textarea"! == c || (b.defaultValue = a.defaultValue)}} função Ha (a, b, c, d) B = f.apply ([], b), var, g, h, i, j, k, m = 0, o = a.length, p = o-1, R = n.isFunção (q)) if (r || o> 1 && "string" == tipo de q &&! L.checkClone && xa.test (q)) return a.each (função (e) {var f = a.eq (E); r (b [0] = q.call (isto, e, f.html ())), Ha (f, b, c, d) A [0] .ownerDocument,! 1, a, d), e = k.firstChild, 1 === k.childNodes.length && (k = e), e || d)) {for (i = n.map (E) (k, "script"), Da), h = i.length; o> m; m ++) g = k, m! == p && (g = n.clone (g, Se h) para (j = i [i.length-1] .ownerDocument, (h, (G, "globalEval"), g = i [m], teste (g.type || "") &&! N._data (i, Ea) && n.contains (j, g) && (g.src? N._evalUrl && n._evalUrl (g.src): n.globalEval ((g.text || g.textContent || g.innerHTML || ""). (Za, ""))); k = e = nulo} return a} função Ia (a, b, c) {para (var, e = b? 0; null! = (D = e [f]); f ++) c || 1! == d.nodeType || n.cleanData (ea (d)), d.parentNode && (c && n.contains (d.ownerDocument, D) && fa (ea (d, "script")), d.parentNode.removeChild (d)); return a} n.extend ({htmlPrefilter: função (a) {return a.replace (va, </ $ 2> ")}, clone: ​​função (a, b, c) {var d, e, f, g, h, i = n.contains (a.ownerDocument, a); if (l.html5Clone || N.isXMLDoc (a) ||! Ua.test ("<" + a.nodeName + ">")? F = a.cloneNode (! 0) :( Ba.innerHTML = a.outerHTML, Ba.removeChild (f = Ba.firstChild)),! (L.noCloneEvent && l.noCloneChecked || 1! == a.nodeType && 11! == a.nodeType || n.isXMLDoc (a))) para (d = ea (f), h = ea (B) se (c) para (h = (g)), H || ea (a), d = d || ea (f), g = 0; null! = (E = h [g]); g ++) Fa (e, d [g] , F); d = e = null, f}, d = e (f, "script"), d.length> 0 && fa (d,! I && ea A, b) {para (var d, e, f, g, h = 0, i = n.expando, j = n.cache, k = l.attributes, m = n.event.special; null! D = a [h]); h ++) se ((b || M (d)) && (f = d [i], g = f && j [f] .events) m [e]? N.event.remove (d, e): n.removeEvent (d, e, g.handle); j [f] && (delete j [f], k || "undefined" == typeof d.removeAttribute? D [i] = void 0: d.removeAttribute (i), c.push (f))}}}), n.fn.extend ({domManip: Ha, detach: function (a ) {Return Ia (this, a,! 0)}, remove: função (a) {return Ia (this, a)}, text: function === a? N.text (this): this.empty (). Append ((this [0] && this [0] .ownerDocument || d) .createTextNode (a))}, null, a, arguments.length )}, Append: function () {return Ha (isto, argumentos, função (a) {if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) { Var b = Ca (isto, a); b.appendChild (a)}})), prepend: function () {return Ha (isto, argumentos, função (a) {if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {var b = Ca (this, a); b.insertBefore (a, b.firstChild)}})}, antes: function () {return (Isto, argumentos, função (a) {this.parentNode && this.parentNode.insertBefore (a, this)})}, depois: function () .insertBefore (a, this.nextSibling)})}, vazio: function () {para (var a, b = 0; null! = (A = this [b]); b ++) {1 === a.nodeType && n .cleanData (ea (a,! 1)); while (a.firstChild) a.removeChild (a.firstChild); a.options && n.nodeName (a, "select") && (a.options.length = 0)} Return this}, clone: ​​função (a, b) {return a = null == a?! 1: a, b = null == b? A: b, this.map (function () {return n.clone Isto, a, b)}), html: função (a) {retorno Y (isto, função (a) {var b = este [0] || {}, c = 0, d = this.length; if (Void 0 === a) return 1 === b.nodeType? B.innerHTML.replace (ta, ""): void 0; if ("string" == typeof a &&! Wa.test (a) && L.htmlSerialize ||! Ua.test (a)) && (l.leadingWhitespace ||! Aa.test (a)) &&! Da [($. Exec (a) || ["", " 1] .toLowerCase ()]) {a = n.htmlPrefilter (a); try {for (; d> c; c ++) b = este [c] || {}, 1 === b.nodeType && (n. CleanData (ea (b,! 1)), b.innerHTML = a); b = 0} catch (e) {}} b && this.empty (). Append (a)}, null, a, arguments.length) , ReplaceWith: function () {var a = []; return Ha (isto, argumentos, função (b) {var c = this.parentNode; n.inArray (this, a) <0 && (n.cleanData )), N.each ({appendTo: "append", prependTo: "prepend", insertBefore: "before", insertAfter: "after", replaceAll), c && c.replaceChild (b, this) : "ReplaceWith"}, função (a, b) {n.fn [a] = função (a) {para (var c, d = 0, e = [], f = n (a), h = f. (C (d)) (b) (c), g.apply (e, c) d = (B) {var c = n (b) () () () () () () () (C), d = n.css (c [0], "display"); return c.detach (), d} função Ma (a) {var b = d, C = Ka [a]; return c || (c = La (a, b), "none"! == c && c || 0 'height =' 0 '/> ")) .adendTo (b.documentElement), b = (Ja [0] .contentWindow || Ja [0] .contentDocument) .document, b.write (), b.close (), C = La (a, b), Ja.detach ()), Ka [a] = c), c} var Na = (A, b, c, d) {var e, f, g = {}, para (f em b) g [f ] = A.style [f], a.style [f] = b [f]; e = c.apply (a, d || []), para (f em b) a.style [f] = g [F]; return e}, Qa = d.documentElement;; function () {var b, c, e, f, g, h, i = d.createElement ("div"), j = d.createElement (" Div "); if (j.style) {j.style.cssText =" float: esquerda; opacidade: .5 ", l.opacity =" 0.5 "=== j.style.opacity, l.cssFloat = !! J.style.cssFloat, j.style.backgroundClip = "content-box", j.cloneNode (! 0) .style.backgroundClip = "", l.clearCloneStyle = "content-box" === j.style.backgroundClip , I = d.createElement ("div"), i.style.cssText = "border: 0; width: 8px; height: 0; top: 0; left: -9999px; padding: 0; margin-top: 1px; Position: absolute ", j.innerHTML =" ", i.appendChild (j), l.boxSizing =" "=== j.style.boxSizing ||" "=== j.style.MozBoxSizing ||" "= == j.style.WebkitBoxSizing, n.extend (l, {reliableHiddenOffsets: function () {return null == b && k (), f}, boxSizingReliable: function () {return null == b && k (), e}, pixelMarginRight : Function () {return null == b && k (), c}, pixelPosition: function () {return null == b && k (), b}, reliableMarginRight: () () {Return null == b && k (), h}}); função k () {var k, l, m = d.documentElement; m.appendChild (i), j.style.cssText = "- Webkit-box-sizing: border-box, caixa-tamanho: border-box, posição: relativo, exibição: bloco, margem: auto, borda: 1px, preenchimento: 1px, top: 1%, largura: 50% = E = h =! 1, c = g =! 0, a.getComputedStyle && (l = a.getComputedStyle (j), b = "1%"! 2px "=== (l || {}). MarginLeft, e =" 4px "=== (l || {width:" 4px "}). Width, j.style.marginRight =" 50% ", c = "4px" === (l || {marginRight: "4px"}). MarginRight, k = j.appendChild (d.createElement ("div")), k.style.cssText = j.style.cssText = "-webkit-box-dimensionamento: content-box;-moz-box-dimensionamento: caixa de conteúdo, dimensionamento de caixa: caixa de conteúdo, exibição: bloco, margem: 0, limite: 0; preenchimento: 0 ", k.style.marginRight = k.style.width =" 0 ", J.style.width =" 1px ", g =! ParseFloat ((a.getComputedStyle (k) || {}). MarginRight), j.removeChild (k)), j.style.display =" none " , F = 0 === j.getClientRects (). Comprimento, f && (j.style.display = "", j.innerHTML = "<table> <tr> <td> </ td> <td> Td> </ tr> </ table> ", j.childNodes [0] .style.borderCollapse =" separar " K [0] .style.display = "", k [1] .style.display [0] .offsetHeight, f && (k [0] .style.display = "" = "None", f = 0 === k [0] .offsetHeight)), m.removeChild (i)}}} (); var Ra, Sa, Ta = $ /; A.getComputedStyle? (Ra = função (b) {var c = b.ownerDocument.defaultView; retorno c && c.opener || (c = a), c.getComputedStyle (b)}, Sa = função (a, B, c) {var d, e, f, g, h = a.style; retorno c = c || Ra (a), g = c? C.getPropertyValue (b) || c [b]: void 0 , ""! == g && void 0! == g || n.contains (a.ownerDocument, a) || (g = n.style (a, b)), c &&! L.pixelMarginRight () && Oa.test G) && Na.test (b) && (d = h.width, e = h.minWidth, f = h.maxWidth, h.minWidth = h.maxWidth = h.width = g, g = c.width, h. (= Função (a) {return a.currentStyle}, Sa = Função (a, b, c) {var d, e, f, g, h = a.style; retorno c = c || Ra (a), g = c? C [b]: void 0, null = = G && h && h [b] && (g = h [b]), Oa.test (g) &&! Ta.test (b) && (d = h.left, e = a.runtimeStyle, f = e && e.left, f && (E.left = a.currentStyle.left), h.left = "fontSize" === b? "1em": g, g = h.pixelLeft + "px", h.left = d, f && (e.left = F)), void 0 === g? G: g + "" || "auto"}); função Ua (a, b) {retorno {get: function () {return a ()? Get: (this.get = b) .apply (this, arguments)}}} var Va = / alpha \ ([^)] * ) +) /, Ya = new RegExp ("^ (" + T + ") (. *) $", " "", "A", "", "", "", "" "", " Bb (a) {if (a em ab) retorna a; var b = a.charAt (0) (C -) if (a = _a [c] + b, a em ab) retorna a} função cb (a, b) { Para (var c, d, e, f = [], g = 0, h = a.length; h> g; g ++) d = a [g], d.style && (f [g] = n._data D, "olddisplay"), c = d.style.display, b? (F [g] || "none"! == c || (d.style.display = ""), "" === d .style.display && W (d) && (f [g] = n._data (d, "olddisplay", Ma (d.nodeName))) :( e = W (d), (c && "none"! (D, "olddisplay", e? C: n.css (d, "display"))))) para (g = 0; h> g; g ++) d = a [ G], d.style && (b && "none"! == d.style.display && ""! == d.style.display || (d.style.display = b? F [g] || "": (A, b, c) {var d = Ya.exec (b); return d? Math.max (0, d [1] - (c || 0)) + (D [2] || "px"): b} função eb (a, b, c, d, e) {para (var f = c === (d? : "Width" === b? 1: 0, g = 0; 4> f; f + = 2) "margin" === c && (g + = n.css (a, c + V [f] , E)), d? ("Conteúdo" == c && (g- = n.css (a, "padding" + V [f] - = n.css (a, "border" + V [f] + "Width",! 0, e))) :( g + = n.css E),) f) (g + = n.css (a, "borda" + V [f] + "Largura" C) {var d =! 0, e = "width" === b? A.offsetWidth: a.offsetHeight, f = Ra (a), g = l.boxSizing && "border-box" === n.css (A, "boxSizing",! 1, f); se (0> = e || null == e) {if (e = Sa (a, b, f) D = g && (l.boxSizingReliable () || e === a.style [b]), e = parseFloat (e) E) || 0} return e + eb (a, b, c || (g? "Border": "conteúdo") d.e) Get: function (a, b) {if (b) {var c = Sa (a, "opacity"); return "" === c? "1": c}}}}, cssNumber: {animationIterationCount :! 0, columnCount:! 0, fillOpacity:! 0, flexGrow:! 0, flexShrink:! 0, fontWeight:! 0, lineHeight:! 0, opacity:! 0, order:! 0, orphans :! 0, widows :! 0, zIndex:! 0, zoom:! 0}, cssProps: {"float": l.cssFloat? "CssFloat": "styleFloat"}, estilo: função (a, b, c, d) {if (a && 3! == a.nodeType && 8! == a.nodeType && a.style) {var e, f, g, h = n.camelCase (b), i = a.style; if (b = n.cssProps [h] || N.cssProps [h] = bb (h) || h), g = n.cssHooks [b] || n.cssHooks [h], void 0 === c) retorna g && "get" em g && void 0! = (E = g.get (a,! 1, d))? E: i [b]; if (f = typeof c, "string" === f && (e = U.exec (c) 1] && (c = X (a, b, e), f = "número"), null! = C && c === c && (n = CssNumber [h]? "": "Px")), l.clearCloneStyle || ""! == c || 0! == b.indexOf ("background") || (i [b] = "inherit" (G && "set" em g && void 0 === (c = g.set (a, c, d))))) try {i [b] = c} : Função (a, b, c, d) {var e, f, g, h = n.camelCase (b); retorno b = n.cssProps [h] || (n.cssProps [h] = bb ), G = n.cssHooks [b] || n.cssHooks [h], g && "get" em g && (f = g.get (a,! 0, c)) void 0 === F && (f = Sa (a, b, d)), "normal" === f && b em $ a && (f = $ a [b] ), C ===! 0 || isFinite (e)? E || 0: f): f}}, n.each (["altura", "largura"], função (a, b) (A, c, d) {return c? Xa.test (n.css (a, "display")) && 0 === a.offsetWidth? Pa (a, Za, (A, b, d): fb (a, b, d): void 0}, conjunto: função (a, c, d) (A, c, d? Eb (a, b, d, l.boxSizing && "border-box" === n.css (a, "boxSizing",! 1, e), e): 0) ), L.opacity || (n.cssHooks.opacity = {get: função (a, b) {return Wa.test ((b && a.currentStyle? A.currentStyle.filter: a.style.filter) || "" ) ?. 01 * parseFloat (RegExp. $ 1) + "": b? 1 ":" "}, conjunto: função (a, b) {var c = a.style, d = a.currentStyle, e = n .isNumeric (b)? "Alpha (opacity =" + 100 * b + ")": "", f = d && d.filter || c.filter || ""; c.zoom = 1, (b> = 1 | | "" === b) && "" === n.trim (f.replace (Va, "")) && c.removeAttribute && (c.removeAttribute ("filter"), "" === b || d && D.filter) || (c.filter = Va.test (f)? F.replace (Va, e): f + "" + e)}}, n.cssHooks.marginRight = Ua (l.reliableMarginRight, Função (a, b) {return b? Pa (a, {display: "inline-block"}, Sa, [a, "marginRight"]): void 0}), n.cssHooks.marginLeft = Ua (l. (A, b) () () () () () () () () () () () {
() {}, Function () {return a.getBoundingClientRect ().)}), N.each ({margin: "", padding: "", border: "Width"}, função (a, b) {n.cssHooks [a + b] = {expand: função (c) {for (var d = 0, e = {}, f = "string" == typeof c ? C.split (""): [c]; 4> d; d ++) e [a + V [d] + b] = f [d] || f [d-2] || f [0]; Retornar e}}, Na.test (a) || (n.cssHooks [a + b] .set = db)}), n.fn.extend ({css: função (a, b) , Função (a, b, c) {var d, e, f = {}, g = 0; se (n.isArray (b)) {para (d = Ra (a), e = b.length; G, g ++) f [b [g]] = n.css (a, b [g], | 1, d); retorno f} retorno void 0! == c? N.style (a, b, c ): Nc (a, b)}, a, b, arguments.length> 1)}, mostre: function () {return cb (this,! 0)}, )}, Toggle: function (a) {return "boolean" == typeof a? A? This.show (): this.hide (): this.each (A, b, c, d, e) {return new gb.prototype.init (a, b, c, d, e) ) N.Tween = gb, gb.prototype = {construtor: gb, init: função (a, b, c, d, e, f) {this.elem = a, this.prop = c, this.easing = E .Esp = this.start = this.now = this.cur (), this.end = d, this.unit = f || (n.cssNumber [c]? ":" Px ")}, cur: function () {var a = gb.propHooks [this.prop]; retornar um && a.get? A.get (this): gb.propHooks._default.get (this)} , Execute: function (a) {var b, c = gb.propHooks [this.prop]; retorna this.options.duration? This.pos = b = n.easing [this.easing] (a, this.options. Duração * a, 0,1, this.options.duration): this.pos = b = a, this.now = (this.end-this.start) * b + this.start, this.options.step && this.options .step.call (this.elem, this.now, this), c && c.set? C.set (this): gb.propHooks._default.set (this), this}}, gb.prototype.init.prototype = Gb.prototype, gb.propHooks = {_ default: {get: função (a) {var b; return 1! == a.elem.nodeType || null! = A.elem [a.prop] && null == a. Elem.style [a.prop]? A.elem [a.prop] :( b = n.css (a.elem, a.prop, ""), b && "auto"! == b? B: 0) }, Set: function (a) {n.fx.step [a.prop]? N.fx.step [a.prop] (a): 1! == a.elem.nodeType || null == a. Elem.style [n.cssProps [a.prop]] &&! N.cssHooks [a.prop]? A.elem [a.prop] = a.now: n.style (a.elem, a.prop, a .now + a.unit)}}}, gb.propHooks.scrollTop = gb.propHooks.scrollLeft = {set: function (a) {a.elem.nodeType && a.elem.parentNode && (a.elem [a.prop] = A.now)}, n.easing = {linear: função (a) {return a}, swing: função (a) {return.5-Math.cos (a * Math.PI) / 2} "Swing"}, n.fx = gb.prototype.init, n.fx.step = {}; var hb, ib, jb = / ^ (?: toggle | show | hide) $ /, kb = / queueHooks $ () {Hb = n.now ()} função mb (a, b) {var c, d = {height: a} E = 0, para (b = b? 1: 0; 4> e; e + = 2-b) c = V [e], d ["margem" + c] = d (B, c) {para (var d, e = (qb.tweeners [b] || []). Concat (qb (C, b, a)) retorna d} função ob (a) (d = e [f] , B, c) {var d, e, f, g, h, i, j, k, m = isto, o = {}, p = a.style, q = a.nodeType && W (a), r = n (A, "fxshow"); c.queue || (h = n._queueHooks (a, "fx"), null == h.unqueued && (h.unqueued = 0, i = h.empty.fire, H.empty.fire = function () {h.unqueued || i ()}, h.unqueued ++, m.always (função () {m.always (function () {h.unqueued -, n.queue (A, "fx"). Comprimento || h.empty.fire ()})})), 1 === a.nodeType && ("height" em b || "width" em b) && (c.overflow = [P.overflow, p.overflowX, p.overflowY], j = n.css (a, "display"), k = "nenhum" === j? N._data (a, "olddisplay") || Ma (a.nodeName): j, "inline" === k && "none" === n.css (a, "float") && (l.inlineBlockNeedsLayout && "inline"! == Ma (a.nodeName)? P.zoom = 1: p.display = "inline-block")), c.overflow && (p.overflow = "hidden", l.shrinkWrapBlocks () || m.always (function () {p.overflow = c (D em b) se (e = b [d], jb.exec (d em b) se (e = b [d], overflow [0], p.overflowX = c.overflow [1], p.overflowY = c.overflow [2] E)) {se (excluir b [d], f = f || "alternar" === e, e === (q? "Ocultar": "mostrar")) {if ("show"! E ||! R || void 0 === r [d]) continue; q =! 0} o [d] = r && r [d] || n.style (a, d)} j = void 0; If (n.isEmptyObject (o)) "inline" === ("none" === j? Ma (a.nodeName): j) && (p.display = j); R && (q = r.hidden): r = n._data (a, "fxshow", {}), f && (r.hidden =! Q), q? N (a) .show (): m.done Função () {n (a) .hide ()}), m.done (função () {var b; n.removeData (a, "fxshow"); para (b em o) n.style (a, b , O [b])}, para (d em o) g = nb (q? R [d]: 0, d, m), d em r || (r [d] = g.start, q && G.end = g.start, g.start = "width" === d || "height" === d? 1: 0))}} função pb (a, b) {var c, d, e , F, g, para (c em a) se (d = n.camelCase (c), e = b [d], f = a [c], n.isArray (f) , F = a [c] = f [0]), c! == d && (a [d] = f, apagar a [c]), g = n.cssHooks [d] {F = g.expand (f), delete a [d]; para (c em f) c em a || (a [c] = f [c], b [c] = e) ] = E} função qb (a, b, c) {var d, e, f = 0, g = qb.prefilters.length, h = n.Deferred () ), I = função () {if (e) return! 1; para (var b = hb || lb (), c = Math.max (0, j.startTime + j.duration-b), d = c /j.duration||0,f=1-d,g=0,i=j.tweens.length;i>g;g++)j.tweens[g].run(f);return h.notifyWith (a , [J, f, c]), 1> f && i? C: (h.resolveWith (a, [j]) 1)}, j = h.promise ({elem: a, props: n.extend {}, B), opts: n.extend (! 0, {specialEasing: {}, easing: n.easing._default}, c), originalProperties: b, originalOptions: c startTime: hb || lb () Duração: c.duration, tweens: [], createTween: função (b, c) {var d = n.Tween (a, j.opts, b, c, j.opts.specialEasing [b] || j.opts (B) {var c = 0, d = b? J.tweens.length: 0; se (e) retornar isto; para ( E = (0, d> c, c ++) j.tweens [c] .run (1), return b? (H.notifyWith (a, [j, 1,0]), h.resolveWith (a, [j , B])): h.reject Com (a, [j, b]), k = j.props; para (pb (k, j.opts.specialEasing); g> f; f ++) if (D = qb.prefilters [f] .call (j, a, k, j.opts)) retorno n.isFunção (d.stop) && (n.queueHooks (j.elem, j.opts.queue) .stop = N.proxy (d.stop, d)), d; retorno n.map (k, nb, j), n.isFunção (j.opts.start) && j.opts.start.call (a, j), N.fx.timer (n.extend (i, {elem: a, anim: j, fila: j.opts.queue})), j.progress (j.opts.progress) .done (j.opts.done , J.opts.complete) .fail (j.opts.fail) .always (j.opts.always)} n.Animation = n.extend (qb, {tweeners: {"*": [função (a, b ) () () () () () () () () () () () () () () () Tc { (A) = a, a = ["*"]): a = a.match (G), para (c, d = 0, e = a.length; e> d; d ++) c = A [b]}, pré-filtros: [ob], pré-filtro: função (a, b) {B? Qb.prefilters.unshift (a): qb.prefilters.push (a)}}), n.speed = função (a, b, c) {var d = a && "object" == typeof a? N .extend ({}, a): {complete: c ||! C && b || n.isFunção (a) && a, duração: a, facilitando: c && b || b &&! Duration = n.fx.off? 0: "number" == typeof d.duration? D.duration: d.duration em n.fx.speeds? N.fx.speeds [d.duration]: n.fx.speeds .,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,, D.com Old) && d.old.call (this), d.queue && n.dequeue (this, d.queue)}, d}, n.fn.extend ({fadeTo: função (a, b, c, d) (A, b, c, d)), animar: () () () () () () ) {Var e = n.isEmptyObject (a), f = n.speed (b, c, d), g = função () {var b = qb (isto, n.extend ({}, a) ; (E, n._data (this, "finish")) && b.stop (! 0)}; return g.finish = g, e || f.queue ===! : This.queue (f.queue, g)}, stop: função (a, b, c) {var d = função (a) {var b = a.stop; delete a.stop, b (c)}; Return "string"! = Typeof a && (c = b, b = a, a = void 0), b && a! ==! 1 && this.queue (a || "fx", [ (=), E = null! = A && a + "queueHooks", f = n.timers, g = n._data (this), if (e) g [e] && g [e] .stop && d F) e) e [e] & gt; e [e] & gt; g (e) .elem! == este || null! = A && f [e] .queue! == a || (f [e] .anim.stop (c), b =! 1, f.splice (e, 1)) (A) {return a! ==! 1 && (a = a || "fx"), this.each (function () { E = c [a + "queueHooks"], f = n.timers, g = d? D.length: 0; para ( C.finish =! 0, n.queue (this, a, []), e & e.stop && e.stop.call (this,! 0), b = f.length; b -;) f [b] .elem === this && f [b] .queue === a && (f [b] .anim.stop (! 0), f.splice (b, 1)); para (b = 0; g> b; b ++) d [B] && d [b] .finish && d [b] .finish.call (this); delete c.finish})}}, n.each (["toggle", "show" A, b) {var c = n.fn [b]; n.fn [b] = função (a, d, e) {return null == a || "boolean" == typeof a? C.apply Isto, argumentos): this.animate (mb (b,! 0), a, d, e)}}), n.each ({slideDown: mb ("show" SlideToggle: mb ("toggle"), fadeIn: {opacity: "show"}, fadeOut: {opacidade: "ocultar"}, fadeToggle: {opacity: "toggle"}}, função (a, b) {n.fn [A] = função (a, c, d) {return this.animate (), n.timers = [], n.fx.tick = function () {var a, B = n.timers, c = 0, para (hb = n.now (); c <b.length; c ++) a = b [c], a () || b [c]! == a || B.splice (c -, 1); b.length || n.fx.stop (), hb = void 0}, n.fx.timer = função (a) {n.timers.push (a), A ()? N.fx.start (): n.timers.pop ()}, n.fx.interval = 13, n.fx.start = function () {ib || (ib = a.setInterval ,,,,,,,,,,,,,,,,,,,,,,,,, , _default: 400}, n.fn.delay = função (b, c) {retorno b = n.fx? N.fx.speeds [b] || b: b, c = c || "fx", este (C, função (c, d) {var e = a.setTimeout (c, b); d.stop = função () {a.clearTimeout (e)}}), function () {var a, B = d.createElement ("input"), c = d.createElement ("div"), e = d.createElement ("select"), f = e.appendChild (d.createElement = D.createElement ("div"), c.setAttribute ("className", "t"), c.innerHTML = "<link /> <table> </ table> <a href='/a'> a < / A> <input type = 'checkbox' /> ", a = c.getElementsByTagName (" a ") [0], b.setAttribute (" type "," checkbox "), c.appendChild (b) C.getElementsByTagName ("a") [0], a.style.cssText = "top: 1px", l.getSetAttribute = "t"! == c.className, l.style = / top / .test (a. GetAttribute ("style")), l.hrefNormalized = "/ a" === a.getAttribute ("href"), l.checkOn = !! b.value, l.optSelected = f.selected, l.enctype = D.createElement ("input"), b.setAttribute ("value", "") ), L.input = "" === b.getAttribute ("valor"), b.value = "t", b.setAttribute ("tipo", "rádio"), l.radioValue = "t" == = B.value} (); var rb = / \ r / g, sb = / [\ x20 \ t \ r \ n \ f] + / g; n.fn.extend ({val: function (a) (C) {var e; 1 === this.nodeType && (E = d? A.call (isto, c, n (este) .val ()): a, null == e? E = "": "number" == typeof e? E + = "": n. IsArray (e) && (e = n.map (e, função (a) {return null == a? "": A + ""})), b = n.valHooks [this.type] || n.valHooks [This.nodeName.toLowerCase ()], b && "set" em b && void 0! == b.set (this, e, "value") || (this.value = e) B = n.valHooks [e.type] || n.valHooks [e.nodeName.toLowerCase ()], b && "get" em b && void 0! == (c = b.get (e, "value"))? C: (c = e.value, "string" == tipo de c? C.replace (rb, ""): null == c? "": C)}}}), n.extend ({ValHooks: { Opção: {get: função (a) {var b = n.find.attr (a, "valor"); return null! = B? B: n.trim (n.text (a) ")}}, Selecione: {get: function (a) {for (var b, c, d = a.options, e = a.selectedIndex, f =" select-one "=== a.type || 0> e, g = f? Null: [], h = f? E + 1: d.length, i = 0> e? H: f? E: [I], (c.selected || i === e) && (l.optDisabled?! C.disabled: null === c.getAttribute ("disabled")) && (! C.parentNode.disabled || ! N.nodeName (c.parentNode, "optgroup"))) {if (b = n (c) .val (), f) retorno b; g.push (b)} retorno g}, set: function (a (B), g = e.length, enquanto (g -) se (d = e [g], n.inArray (n (D), f)> - 1) try {d.selected = c =! 0} catch (h) {d.scrollHeight} else d.selected = | 1; return c || (a .selectedIndex = -1), n.each (["radio", "checkbox"], function () {n.valHooks [this] = {set: função (a, b) {return N.isArray (b)? A.checked = n.inArray (n (a) .val (), b)> - 1: void 0}}, l.checkOn || (n.valHooks [this] .get = Função (a) {return null === a.getAttribute ("valor")? "On": a.value})}; var tb, ub, vb = n.expr.attrHandle, wb = / ^ Selecionado) $ / i, xb = l.getSetAttribute, yb = l.input; n.fn.extend ({attr: função (a, b) {return Y (this, n.attr, a, b, Arguments.length> 1)}, removeAttr: function (a) {return this.each (function () {n.removeAttr (this, a)})}}), n.extend ({attr: function (a, b ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,, C): (1 === f && n.isXMLDoc (a) || (b = b.toLowerCase (), e = n.attrHooks [b] || (n.expr.match.bool.test (b)? Ub (A, b): e && "set" em e && void 0! == (d = e.set (a, c, b) ) D: (a.setAttribute (b, c + ""), c): e && "get" em e && null! == (d = e.get (a, b) .attr (a, b), null == d? Void 0: d))}, attrHooks: {type: {set: function (a, b) {if !.radioValue && "radio" === b && n. (A, "input")) {var c = a.value; return a.setAttribute ("type", b), c && (a.value = c), b}}}}, removeAttr: function (a, B) (c = f [e ++]) d = n.propFix [c] || (b) {var c, d, e = 0, f = b && b.match (G); if (f && 1 === a.nodeType) C, n.expr.match.bool.test (c)? Yb && xb ||! Wb.test (c)? A [d] =! 1: a [n.camelCase ("default -" + c)] = a [D] =! 1: n.attr (a, c, ""), a.removeAttribute (xb? C: d) ==! 1? N.removeAttr (a, c): yb && xb ||! Wb.test (c)? A.setAttribute (! Xb && n.propFix [c] || c, c): a [n.camelCase (A) () () () () () () () () () () Vb [b] = função (a, b, d) {var e, f; return d || (b, b) || n.find.attr; yb && xb ||! Wb.test (b) Vb [b] = e, e = null! = C (a, b, d)? B.toLowerCase (): null, vb [b] = f) ] = Função (a, b, c) {return c? Void 0: a [n.camelCase ("default -" + b)]? B.toLowerCase (): null}}), yb && xb || (n.attrHooks .value = {set: function (a, b, c) {retorno n.nodeName (a, "input")? Void (a.defaultValue = b): tb && tb.set (a, b, c) Xb || (tb = {set: função (a, b, c) {dd = a.getAttributeNode (c); retorno d || a.setAttributeNode (d = a.ownerDocument.createAttribute (c)), d. Valor = b + = "", "valor" === c === a.getAttribute (c)? B: void 0}}, vb.id = vb.name = vb.coords = function (a, B, c) {var d; return c? Void 0: (d = a.getAttributeNode (b)) && "!! == d.value? D.value: null}, n.valHooks.button = {get: Função (a, b) {var c = a.getAttributeNode (b); retorno c && c.specified? C.value: void 0}, set: tb.set}, n.attrHooks.contenteditable = B, c) {tb.set (a, "" === b ?! 1: b, c)}}, n.each (["largura", "altura"], função (a, b) .attrHooks [b] = {set: função (a, c) {return "" === c? (A.setAttribute (b, "auto"), c): void 0}}}), l.style || (n.attrHooks.style = {get: função (a) {return a.style.cssText || void 0}, set: função (a, b) {return a.style.cssText = b + ""}} ); Var Zb = / ^ (?: entrada | selecione | textarea | botão | objeto) $ / i, Ab = / ^ (?: a | área) $ / i; n.fn.extend ({prop: function A, b) {return Y (isto, n.prop, a, b, arguments.length> 1)}, removeProp: function (a) {return a = n.propFix [a] Function {) {try {this [a] = void 0, delete this [a]} catch (b) {}})}}), n.extend ({prop: function (a, b, c) , E, f = a.nodeType; if (3! == f && 8! == f && 2! == f) return 1 === f && n.isXMLDoc (a) || (b = n.propFix [b] || b , E = n.propHooks [b]), void 0! == c? E && "set" em e && void 0! == (d = e.set (a, c, b) C: e && "get" em e && null! == (d = e.get (a, b))? D: a [b]}, propHooks: {tabIndex: {get: function (a) {var b = n. Find.attr (a, "tabindex"); return b? ParseInt (b, 10): zb.test (a.nodeName) || Ab.test (a.nodeName) && a.href? 0: -1}}} , PropFix: {"for": "htmlFor", "class": "className"}}), l.hrefNormalized || n.each (["href", "src"], função (a, b) .propHooks [b] = {get: função (a) {return a.getAttribute (b, 4)}}}, l.optSelected || (n.propHooks.selected = {get: função (a) {var b = A.parentNode; return b && (b.selectedIndex, b.parentNode && b.parentNode.selectedIndex), null}, set: function (a) {var b = a.parentNode; b && (b.selectedIndex, b.parentNode && b.parentNode. SelectedIndex)}}, n.each (["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap" ], Function () {n.propFix [this.toLowerCase ()] = this}), l.enctype || (n.propFix.enctype = "codificação"); var Bb = / [\ t \ r \ n \ F] / g; função Cb (a) {retorno n.attr (a, "classe") n.fn.extend ({addClass: função (a) {var b, c, d, F, g, h, i = 0; if (n.isFunção (a)) return this.each (função (b) {n (this) .addClass (a.call (this, b, Cb (this))) }); If ("string" == typeof a && a) {b = a.match (G) || []; enquanto (c = este [i ++]) se (e = Cb (c), d = 1 == = C.nodeType && ("" + e + "") .replace (Bb, "")) {g = 0; enquanto (f = b [g ++]) d.indexOf (" = F + "") h = n.trim (d), e! == h && n.attr (c, "classe", h)}} return this}, removeClass: function (a) {var b, c, d ,,,,,,,,,,,,,, F, g, h, i = 0, if (n.isFunção (a)) return this.each ))))); If (! Arguments.length) retorna this.attr ("class", ""); if ("string" == typeof a && a) {b = a.match (G) || []; Enquanto (c = este [i ++]) se (e = Cb (c), d = 1 === c.nodeType && ("" + e + "") .replace (Bb, "")) {g = 0; (F = b [g ++]) enquanto (d.indexOf ("" + f + "")> - 1) d = d.replace ("" + f + "" ,,,,,,,,,,, E! == h && n.attr (c, "classe", h)}} return this}, toggleClass: function (a, b) == c? B? This.addClass (a): this.removeClass (a): n.isFunction (a)? This.each (function (c) {n (this) .toggleClass (a.call , Cb (this), b), b)}): this.each (função () {var b, d, e, f; if ("string" === c) {d = 0, e = n Isto), f = a.match (G) || []; enquanto (b = f [d ++]) e.hasClass (b)? E.removeClass (b): e.addClass (b)} else void 0! == a && "boolean"! == c || (b = Cb (this), b && n._data (isto, "__ className __", b), n.attr (this, "class", b || a === (), () () () () () () () () () () () () () () ; While (c = this [d ++]) se (1 === c.nodeType && ("" + Cb (c) + "") .replace (Bb, "") .indexOf (b)> - 1) return! 0, return! 1}}), n.each ("blur focus focusin focusout carga redimensionamento scroll unload clique em dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave alterar selecionar enviar keydown keypress keyup erro contextmenu" .split ("") , B) {n.fn [b] = função (a, c) {return arguments.length> 0? This.on (b, null, a, c): this.trigger (b)}}), n. Fn.extend ({hover: função (a, b) {return this.mouseenter (a) .mouseleave (b || a)}}; var Db = a.location, Eb = n.now (), Fb = / \? /, Gb = / (,) | \\ [| {} | (} |)) | "(?: [^" \\\ r \ n] | \\ ["\\\ / bfnrt] | \\ u [\ da-fA-F] {4}) * "\ s *:? | True | false | null | -? (?! 0 \ d) \ d + (?: \. \ D + |) (?: [EE] [+ -]? \ D + |) /g;n.parseJSON=function (b) {if (a.JSON && a.JSON.parse) retornam a.JSON.parse (b + ""); var C, d = null, e = n.trim (b + ""); return e &&! N.trim (e.replace (Gb, função (a, b, e, f) Função ("return" + e) ​​(): n.error ("JSON inválido:") + B)}, n.parseXML = função (b) {var c, d; if (! B || "string"! = Typeof b) retorna null; try {a.DOMParser? (D = new a.DOMParser, C = d.parseFromString (b, "text / xml")) :( c = novo a.ActiveXObject ("Microsoft.XMLDOM"), c.async = "false", c.loadXML (b) ) {C = void 0} return c && c.documentElement &&! C.getElementsByTagName ("parsererror"). Length || n.error ("XML inválido:" + b), c} Ib = / ([?]] _ = [^ &] * /, Jb = / ^ (. *?): [\ T] * ([^ \ r \ n) Kb = / ^ (?: about | app | app-storage. + - extensão | file | res | widget): $ /, Lb = / ^ (?: GET | HEAD) \ //, Nb = / ^ ([\ w. + -] +:) (?: \ / \ / (?: [^ \ /? #] ) (? :: (\ d +) |)) /, Ob = {}, Pb = {}, Qb = "* /". Concat ("*"), Rb = Db.href, Sb = Nb.exec (Rb.toLowerCase ()) || []; função Tb (a) {função de retorno (b, c) {"string"! = Tipo de b && (c = b, b = "*") 0, f = b.toLowerCase (). Match (G) || []; if (n.isFunção (c)) while (d = f [e ++]) "+" === d.charAt (0)? (D = d.slice (1) || "*", (a [d] = a [d] || []) unshift (c)) :( a [d] = a [d] Função g (h) {var i; return e [h] = f = a === função P (a, b, c, d) (A, h) {var j = h (b, c, d); retorno "string"! = Tipo de j || f || e [ J]? F?! (I = j): void 0: (b.dataTypes.unshift (j), g (j), | 1)}), i} return g (b.dataTypes [0]) || ! E ["*"] && g ("*")} função Vb (a, b) {var c, d, e = n.ajaxSettings.flatOptions || {}; para (d em b) void 0! B [d] && (e [d]? A: c || (c = {})) | d] = b [d]); retorno c && n.extend (! 0, a, c), a} Wb (a, b, c) {var d, e, f, g, h = a.contents, i = a.dataTypes; enquanto ("*" === i [0]) i.shift (), void (E) para (g em h) se (h [g] && h [g] .test (e) ) {I.unshift (g); break} se (i [0] em c) f = i [0] (D = g)} f = f || d} return f? (F! == i [0] && i.unshift (f) , C [f]): void 0} função Xb (a, b, c, d) {var e, f, g, h, i, j = {}, k = a.dataTypes.slice () K [1]) para (g em a.converters) j [g.toLowerCase ()] = a.converters [g]; f = k.shift (); enquanto (f) if (a.responseFields [f] && (C [a.responseFields [f]] = b), .i && d && a.dataFilter && (b = a.dataFilter (b, a.dataType)) i = f, f = k.shift () = F f = i; else if ("*"! == i && i! == f) {if (g = j [i + "" + f] || j ["*" + f] ) Para (e em j) se (h = e.split (""), h [1] === f && (g = j [i + "" + h [0]] || j ["*" + h [0]]) g = j [e]: j [e]! ==! 0 && (f = h [0], k.unshift (h [1])) } If (g! ==! 0) se (g && a ["lança"]) b = g (b), senão try {b = g (b)} catch (l) {return {estado: "parsererror" : "Nenhuma conversão de" + i + "para" + f}}} return {estado: "sucesso", data: b}} n.extend ({active: 0, lastModified: {}, etag: }, AjaxSettings: {url: Rb, tipo: "GET", isLocal: Kb.test (Sb [1]), global:! 0, processData:! 0, async:! 0, contentType: "application / x-www -form-urlencoded; Charset = UTF-8 ", aceita: {" * ": Qb, texto:" text / plain ", html:" text / html ", xml:" application / xml, text / xml " , Text / javascript "}, conteúdo: {xml: / \ bxml \ b /, html: / \ bhtml /, json: / \ bjson \ b /}, responseFields: , Json: "responseJSON"}, conversores: {"* text": String, "text html":! 0, "text json": n.parseJSON, "text xml": n.parseXML}, flatOptions: ), AjaxSetup: function (a, b) {return b? Vb (Vb (a, n.ajaxSettings), b): Vb (n.ajaxSettings, a)}, ajaxPrefilter: Tb Ob), ajaxTransport: Tb (Pb), ajax: função (b, c) {"objeto" == tipo de b && (c = b, b = void 0) F, g, h, i, j, k, l = n.ajaxSetup ({}, c), m = l.contexto || l, o = l.contexto && (m.nodeType || m.jquery)? N (M): n.event, p = n.Deferred (), q = n.Callbacks ("uma vez memória"), r = l.statusCode || {}, s = {}, t = {} 0, v = "cancelado", w = {readyState: 0, getResponseHeader: função (a) {var b; if (2 === u) {if (! K) {k = {} B = k [a.toLowerCase ()]} return null == b? Null: b}, getAllResponseHeaders: function () {Return 2 === u? G: null}, setRequestHeader: função (a, b) {var c = a.toLowerCase (); retorno u || (a = t [c] = t [c] || a , A função {a) {var b; if (a) {return u || (l.mimeType = a), this} (B) = [r [b], a [b]], então w (sempre) (a [w.status]), return this}, abort: function (a) (B), y (0, b), este}}, se (p.promise (w) .complete = q.add, w.success = w.done , W.error = w.fail, l.url = ((b || l.url || Rb) + "") Substituir (Hb, "") Substituir (Mb, Sb [1] + "// "), L.type = c.method || c.type || l.method || l.type, l.dataTypes = n.trim (l.dataType ||" * "). ToLowerCase (). Match ( G)], null == l.crossDomain && (d = Nb.exec (l.url.toLowerCase ()), l.crossDomain =! (! D || d [1] === Sb [ 1] && d [2] === Sb [2] && (d [3] || ("http:" === d [1]? "80": "443" ] || ("http:" === Sb [1]? "80": "443")))), l.data && l.processData && "string"! = Typeof l.data && (l.data = n.param (L.data, l.traditional)), Ub (Ob, l, c, w), 2 === u) retorno w; i = n.event && l.global, i && 0 === n.active ++ && n. Event.trigger ("ajaxStart"), l.type = l.type.toUpperCase (), l.hasContent =! Lb.test (l.type), f = l.url, l.hasContent || (l.data && (F = l.url + = (Fb.test (f)? "&": "?") + L.data, delete l.data), l.cache ===! 1 && (l.url = Ib.test (F)? F.replace (Ib, "$ 1 _ =" + Eb ++): f + (Fb.test (f)? "&": "?)), L.ifModified && N.lastModified [f] && w.setRequestHeader ("If-Modified-Since", n.lastModified [f]), n.etag [f] && w.setRequestHeader ("If-None- ), (L.data && l.hasContent && l.contentType! ==! 1 || c.contentType) && w.setRequestHeader ("Content-Type", l.contentType), w.setRequestHeader ("Accept", l.dataTypes [0 ] && l.accepts [l.dataTypes [0]] l.accepts [l.dataTypes [0]] + ("*"! == l.dataTypes [0]? "," + Qb + "; Q = 0.01 ":" "): l.accepts [" * "]) para (e em l.headers) w.setRequestHeader (e, l.headers [e]); if (l.beforeSend && (l.beforeSend .call (m, w, l) ===! 1 || 2 === u)) return w.abort (); v = "abort"; para (e em {success: 1, error: 1, complete : 1}) w [e] (l [e]), se (j = Ub (Pb, l, c, w)) {if (w.readyState = 1, i && o.trigger (ajaxSend, w, L]), 2 === u) return w; l.async && l.timeout> 0 && (h = a.setTimeout (função () {w.abort (timeout)}, l.timeout) = 1, j.send (s, y)} capturar (x) {if (! (2> u)) lançar x; y (-1, x)}} else y (-1, "No Transport"); Função y (b, c, d, e) {var k, s, t, v, x, y = c; 2! == u && (u = 2, h && a.clearTimeout (h), j = void 0, g = E || "", w.readyState = b> 0? 4: 0, k = b> = 200 && 300> b || 304 === b, d && (v = Wb (l, w, d) = Xb (l, v, w, k), k (l.ifModified && (x = w.getResponseHeader ("Last-Modified"), x && (n.lastModified [f] = x), x = w.getResponseHeader "Etag"), x && (n.etag [f] = x)), 204 === b || "HEAD" === l.type? Y = "nocontent": 304 === b? Y = (Y = v.state, s = v.data, t = v.error, k =! T)) :( t = y,! B && y || (y = "error", 0> b && = 0)), w.status = b, w.statusText = (c || y) + "", k? P.resolveWith (m, [s, y, w]): p.rejectWith (m, W, y, t]), w.statusCode (r), r = void 0, i && o.trigger (k? "AjaxSuccess": "ajaxError" (M, [w, y]), i && (o.trigger ("ajaxComplete", [w, l]), - n.active || n.event.trigger ("ajaxStop")) , GetJSON: função (a, b, c) {return n.get (a, b, c, "json")}, getScript: function (a, b) (A, b) {n [b] = função (a, c, d, e) {return n.isFunction (a) C, e = c, c = void 0), n.ajax (n.extend ({url: a, tipo: b, dataType: e, dados: c, sucesso: d} , N.isPlainObject (a) && a))}}), n._evalUrl = função (a) {return n.ajax ({url: a, type: "GET", dataType: Async:! 1, global:! 1, "throws":! 0})}, n.fn.extend ({wrapAll: função (a) {if (n.isFunction (a)) return this.each (function B) {n (this) .wrapAll (a.call (this, b))}; if (this [0]) {var b = n (a, this [0] .ownerDocument) .eq (0). Clone (! 0); this [0] .parentNode && b.insertBefore (this [0]), b.map (function () {var a = this; while (a.firstChild && 1 === a.firstChild.nodeType) a = (A) {return n.isFunction (a)? This.each (função (b) {n (this)} .wrapInner (a) .call (this, b))}): this.each (função () {var b = n (este), c = b.contents (); c.length? C.wrapAll (a): b.append A)}, wrap: function (a) {var b = n.isFunção (a); retorna this.each (função (c) {n (this) .wrapAll : A)})}, unwrap: function () {return this.parent (). Each (function () {n.nodeName (this, "body") || n (this) .replaceWith (this.childNodes)} ) .end ()}}) função Yb (a) {return a.style && a.style.display || n.css (a, "display")} função Zb (a) {if (! N.contains (a .ownerDocument || d, a)) return! 0; while (a && 1 === a.nodeType) {if ("none" === Yb (a) || "hidden" === a.type) return! 0; a = a.parentNode} return! 1} n.expr.filters.hidden = função (a) {return l.reliableHiddenOffsets ()? A.offsetWidth <= 0 && a.offsetHeight <= 0 &&! A.getClientRects (). Comprimento: Zb (a)}, n.expr.filters.visible = função (a) {retorno! N.expr.filters.hidden (a)}; var $ b = /% 20 / g, _b = / \ \] $ /, Ac = / \ r? \ N / g, bc = / ^ (?: enviar | botão | imagem | repor ficheiro] $ / i, cc = / ^ (?: input | select | textarea | Keygen) / i; função dc (a, b, c, d) {var e; if (n.isArray (b)) n.each (b, função (b, e) {c || _b.test (a ) D (a, e): dc (a + "[" + ("objeto" == tipo de e && null! = E? B: C || "objeto"! == n.tipo (b)) d (a, b), para (e em b) dc (a + "[" + e + "]", b [e], c, d ) N.param = função (a, b) {var c, d = [], e = função (a, b) {b = n.isFunção (b)? B (): null == b? "" : B, d [d.length] = codificarURIComponente (a) + "=" + codificarURIComponente (b)}; if (void 0 === b && (b = n.ajaxSettings && n.ajaxSettings.traditional), n.isArray ) || a.jquery &&! N.isPlainObject (a)) n.each (a, function () {e (this.name, this.value)}) C], b, e); return d.join ("&"). Replace ($ b, "+")}, n.fn.extend ({serialize: function () {return n.param (this.serializeArray (), SerializeArray: function () {return this.map (function () {var a = n.prop (this, "elements"); return a? N.makeArray (a): this} Function () {var a = this.type; return this.name &&! N (this) .is (": disabled") && cc.test (this.nodeName) &&! Bc.test (a) && (this.checked | (Z) () () () () () () () () () () () () () () () () () () () (C, função (a) {return {nome: b.name, valor: a.replace (ac, "\ r \ n")}}: {name: b.name, value: c.replace (ac , "\ R \ n")}}), n.ajaxSettings.xhr = void 0! == a.ActiveXObject? Function () {return this.isLocal? Ic (): d.documentMode > 8? Hc (): / ^ (get | post | head | put | delete | options) $ / i.
Padding: "inner" + a, content: b, "": "exterior" + a}, função (c, d) C || "boolean"! = Typeof d), g = c || (d ===! 0 || e ===! 0? "Margin": "border"); , C, d) {var e; return n.isWindow (b)? B.document.documentElement ["client" + a]: 9 === b.nodeType? (E = b.documentElement, Math.max (b E ["deslocamento" + a], e ["deslocamento" + a], e ["deslocamento" + a] Void 0 === d? N.css (b, c, g): n.estilo (b, c, d, g)}, b, f? D: void 0, f, null) , N.fn.extend ({bind: função (a, b, c) {return this.on (a, null, b, c)}, unbind: função (a, b) {return this.off (a, (B, a, c, d)}, undelegate: função (a, b, c) {return 1 === Arguments.length? This.off (a, "**"): this.off (b, a || "**", c)}}), n.fn.size = function () {return this.length }, N.fn.andSelf = n.fn.addBack, "function" == typeof define && define.amd && define ("jquery", [], function () {return n}) var nc = a.jQuery, oc = a . $; Return n.noConflict = função (b) {return a. $ === n && (a. $ = Oc), b && a.jQuery === n && (a.jQuery = nc), n}, b || (A.jQuery = a. $ = N), n});